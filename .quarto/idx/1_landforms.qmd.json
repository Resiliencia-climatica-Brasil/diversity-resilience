{"title":"Variedade de formas do relevo","markdown":{"yaml":{"title":"Variedade de formas do relevo","jupyter":"python3"},"headingText":"Importando pacotes e inicializando *geemap*","containsRefs":false,"markdown":"\n\n\n\n\n```{python}\nimport os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n```\n\n```{python}\ngeemap.ee_initialize()\n```\n\n## Classificando as formas do relevo\n\n### Formas do relevo\n\nUtilizamos a metodologia proposta por @anderson_resilient_2016 para definir as formas de relevo (do inglês, *landforms*). As formas de relevo geradas foram: \n\n\n* **3 - Cool Steep Slope**\n* **4 - Warms Steep Slope**\n* **5 - Cliff**\n* **11 - Summit/Ridgetop**\n* **13 - Slope Crest**\n* **21 - Flat Hilltop**\n* **22 - Gentle Slope Hilltop**\n* **23 - Cool Sideslope**\n* **24 - Warm Sideslope**\n* **30 - Dry Flats**\n* **32 - Valley/Toeslope**\n* **39 - Moist Flats**\n* **43 - Cool Footslope**\n* **44 - Warm Sideslope**\n\n### Variáveis classificadoras das formas de relevo\n\nAs variáveis utilizadas para calcular as formas de relevo foram: **declividade** (*slope*), **exposição** (*aspect*), **Índice de Posição Topográfica** (*TPI*, do inglês *Topographic Position Index*) e **índice de umidade** (*moisture index*). As formas de relevo são classificadas principalmente por declividade e TPI (Figura 1). A exposição classifica as faces *quentes* ou *frias* do relevo e o índice de umidade classifica as áreas planas em secas ou úmidas. \n\n![](figura/landform_scheme.png)\n\n    Figura 1. Classificação das formas de relevo pela declividade, exposição, índice de posição topográfica e índice de umidade. Adaptação de @anderson_resilient_2016.\n    \n\nAs variáveis foram discretizadas em classes e combinadas para comporem os tipos de formas de relevo. Os limiares utilizados para a discretização (Tabela 1) foram definidos por ajustes visuais que melhor representavam as formas de relevo.\n\n\n               Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n| Variável| Classe | Limiar inferior | Limiar superior |\n|:-:|:-:|:-:|:-:|\n|Declividade|1|-1|2|\n|Declividade|2|2|6|\n|Declividade|3|6|24|\n|Declividade|4|24|35|\n|Declividade|5|35|90|\n|TPI|1|-Inf|-15|\n|TPI|2|-15|-1|\n|TPI|3|-1|30|\n|TPI|4|30|975|\n|Exposição|2|0|90|\n|Exposição|1|90|270|\n|Exposição|2|270|360|\n|Índice de umidade|0|-Inf|30000|\n|Índice de umidade|1|3000|Inf|\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de índice de umidade, 2 de exposição, 3 de TPI e 1 de declividade. Posteriormente, os valores finais foram convertidos em tipos de formas de relevo, seguindo a classificação indicada na Tabela 2.\n\n    Tabela 2. Tabela 2. Critério de conversão dos códigos da combinação de classes em tipos de formas de relevo.\n    \n|Código|Formas de relevo|\n|:-:|:-:|\n|10|11|\n|11|11|\n|12|11|\n|13|13|\n|14|11|\n|15|5|\n|20|21|\n|21|21|\n|22|22|\n|23|24|\n|24|24|\n|25|5|\n|31|30|\n|32|32|\n|33|24|\n|34|24|\n|35|5|\n|40|32|\n|41|32|\n|42|32|\n|43|43|\n|44|3|\n|45|5|\n|51|51|\n|111|11|\n|112|11|\n|113|13|\n|114|3|\n|115|5|\n|121|21|\n|122|22|\n|123|23|\n|124|3|\n|125|5|\n|131|30|\n|132|32|\n|133|23|\n|134|3|\n|135|5|\n|141|32|\n|142|32|\n|143|43|\n|144|3|\n|145|5|\n|151|51|\n|211|11|\n|212|11|\n|213|13|\n|214|4|\n|215|5|\n|221|21|\n|222|22|\n|223|24|\n|224|4|\n|225|5|\n|231|30|\n|232|32|\n|233|24|\n|234|4|\n|235|5|\n|241|32|\n|242|32|\n|243|44|\n|244|4|\n|245|5|\n|251|51|\n|1000|39| \n\n## Cálculo da variedade de formas de relevo\n\n### Bases de dados\n\nClassificamos as formas de relevo utilizando o Modelo Digital de Elevação (DEM) do Merit-DEM [@yamazaki_high-accuracy_2017], o acúmulo de fluxo do Merit-Hydro [@yamazaki_merit_2019] e a camada de uso do solo do MapBiomas [@mapbiomas_project_collection_2020]. O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do *Shuttle Radar Topography Mission* (SRTM) [@farr_shuttle_2007] e *Advanced Land Observing Satellite* (ALOS) [@tadono_t_precise_2014], permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como *speckle noise*, *stripe noise*, *absolute bias* e *tree height bias* [@yamazaki_high-accuracy_2017]. A correção de *tree height bias* é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\n\nIncluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto. \n\n## Códigos para a criação da variedade de formas do relevo\n\nAs análises foram rodadas no *Google Earth Engine* [@gorelick_google_2017], devido a demanda computacional do projeto, usando o pacote **geemap** [@wu_geemap_2020] em *Python* [@python_software_foundation_python_2023] como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para replicação da análise pode ser baixado em [https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb](https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb).\n\n### Declividade (*slope*)\n\nNós criamos a superfície de declividade a partir do Merit-DEM.\n\n```{python}\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando a declividade\n\nslope = ee.Terrain.slope(DEM)\n```\n\n### Exposição (*aspect*)\n\nNós calculamos a exposição do relevo utilizando o mesmo DEM.\n\n```{python}\naspect = ee.Terrain.aspect(DEM)\n```\n\n### Índice de Posição Topográfica (TPI)\n\nNós calculamos o Índice de Posição Topográfica (TPI)[@weiss_topographic_2001] para cada célula do *raster* dentro de um *kernel* circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\n$TPI = \\frac{\\sum_{i}^{n}(vizinhança_i -  focal)}{n}$\n\na vizinhança *i* representa cada uma das *n* células dentro do *kernel* da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional [@theobald_ecologically-relevant_2015]. Os tamanhos das janelas foram definidos visualmente para que melhor representassem as formas do relevo, principalmente os *Summits*, *Valleys*, *Toeslopes* e *Hilltops* (*flat* e *gentle*). Os tamanhos das janelas também tinham que capturar os platôs das Chapadas como *Summits*. \n\n```{python}\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n```\n\n```{python}\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n```\n\n### Índice de umidade (*Moisture index*)\n\nNós calculamos o índice de umidade [@anderson_resilient_2016] baseado no acúmulo de fluxo presente no Merit-Hydro [@yamazaki_merit_2019], na camada **upg**, que é calculado sobre o Merit-DEM. O índice de umidade é calculado da seguinte forma:\n\n$moisture.index = \\frac{\\log(fluxo + 1)}{(declividade + 1)} \\times 1000$\n\nonde ***fluxo*** é o acúmulo de fluxo e ***declividade*** é a calculada anteriormente. O índice de umidade é a média do índice dentro de um *kernel* circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d'água.\n\n```{python}\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o índice de umidade\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)\n```\n\n## Convertendo variáveis em classes\n\n### Declividade (*slope*)\n\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo [@anderson_resilient_2016]. As classes de declividade foram criadas com o seguinte código:\n\n```{python}\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n```\n\n### Exposição (*aspect*)\n\nA exposição foi escolhido para definir as faces quentes e frias no hemisfério sul.\n\n```{python}\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2) # face quente\n    .where(aspect.gt(90).And(aspect.lte(270)), 1) # face fria\n    .where(aspect.gt(270).And(aspect.lte(360)), 2) # face quente\n)\n```\n\n### Índice de Posição do Relevo (TPI)\n\nAs classes de TPI foram definidas para representarem bem os *Summits*, *Valleys*, *Toeslopes* e *Hilltops*, que foram as formas do relevo mais difíceis de ajustar os parâmetros.\n\n```{python}\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n```\n\n### Índice de Umidade (*moisture index*)\n\nO limiar do índice de umidade para classificar as áreas como umidas ou secas foi definido visualmente para capturar a distribuição dos cursos d'água sem criar áreas planas secas com excesso de ramificações dendríticas. Os grandes rios, represas e lagoas (ex. Rio Amazonas) não foram bem representados pelo índice de umidade, pois ele classificava somente as partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d'água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a classe de águas presente no MapBiomas.\n\n```{python}\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n```\n\n### Combinando as classes\n\nCombinamos as classes para gerar um código representativo de cada variável. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1.  \n\n```{python}\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n```\n\n### Classificando as formas do relevo\n\nClassificamos as formas do relevo pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as formas do relevo. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (*Summit*). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de formas de relevo como *Sideslopes* de *Valleys* e *Toeslopes*. \n\n```{python}\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n```\n\n### Exportando mapas para assets\n\n```{python}\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n```\n\n```{python}\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=regiao_box, scale=escala,maxPixels=1e13\n)\n```\n\n### Exemplo de formas de relevo\n\nAbaixo está uma representação das formas de relevo na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n```{python}\n%%capture --no-display\n#| echo: false\n\n# Delimitando a região\nbb = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=bb, file_per_band=False\n)\n```\n\n```{python}\n# Paleta de cores das formas de relevo\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n```\n\n          Figura 2. Formas de relevo classificadas na região de Alto Paraíso de Goiás-GO, Brasil.\n\n## Calculando a variedade de formas de relevo\n\nA variedade de formas do relevo foi calculada como a soma dos tipos de formas dentro de um *kernel* circular de uma célula focal. O tamanho do raio do *kernel* foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele no qual o raio subsequente não adicionou variedade. Dessa forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de formas do relevo. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de formas do relevo para a mesma região de Alto Paraíso de Goiás-GO.\n\n```{python}\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n```\n\n```{python}\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=bb, file_per_band=False\n)\n```\n\n```{python}\n#| scrolled: true\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n```\n\n            Figura 3. Variedade de formas de relevo para região de Alto Paraíso de Goiás-GO, Brasil.\n\n```{python}\n# modifique o assetId para o endereço do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,maxPixels=1e13\n)\n```\n\n## Conferir a criação do *asset* \n\nO *asset* pode demorar algumas horas para se criado. Para conferir se o *asset* foi criado, rode a linha de comando abaixo para buscar o nome do *asset* na nuvem do GEE. Se não funcionar confira [aqui](https://developers.google.com/earth-engine/guides/command_line) como instalar as funções para uso da linha de comando.\n\n```{python}\nos.system(f\"earthengine ls projects/ee-lucasljardim9/assets| grep 'assets/landform_variety'\")\n```\n\nOutra possibilidade é acessar a página do [editor de código](https://code.earthengine.google.com) do GEE e na parte direita da tela, em **Tasks** confira se o processo de criação finalizou com sucesso, colorido em azul. Vermelho indica que houve algum erro durante o processo.  \n\n\n![](figura/tasks.png)\n\nTambém é possível ver os *assets* na aba **Assets**, na parte esquerda da tela.\n\n![](figura/asset.png)\n\nVeja o dado criado com:\n\n```{python}\n# Paleta de cores\nsld_intervals =(\n'<RasterSymbolizer>' + \\\n  '<ColorMap type=\"intervals\" extended=\"False\">' + \\\n    '<ColorMapEntry color=\"#ffc408\" quantity=\"3\" label=\"Cool Steep Slope\"/>' + \\\n    '<ColorMapEntry color=\"#ffa101\" quantity=\"4\" label=\"Warm Steep Slope\"/>' + \\\n    '<ColorMapEntry color=\"#ef595a\" quantity=\"5\" label=\"Cliff\"/>' + \\\n    '<ColorMapEntry color=\"#ffbdbe\" quantity=\"11\" label=\"Summit/Ridgetop\"/>' + \\\n    '<ColorMapEntry color=\"#6e4100\" quantity=\"13\" label=\"Slope Crest\"/>' + \\\n    '<ColorMapEntry color=\"#af7b53\" quantity=\"21\" label=\"Flat Hilltop\"/>' + \\\n    '<ColorMapEntry color=\"#c8c284\" quantity=\"22\" label=\"Gentle Slope Hilltop\"/>' + \\\n    '<ColorMapEntry color=\"#c8f6ad\" quantity=\"23\" label=\"Cool Sideslope\"/>' + \\\n    '<ColorMapEntry color=\"#83e763\" quantity=\"24\" label=\"Warm Sideslope\"/>' + \\\n    '<ColorMapEntry color=\"#ffffbe\" quantity=\"30\" label=\"Dry Flats\"/>' + \\\n    '<ColorMapEntry color=\"#a9a800\" quantity=\"32\" label=\"Valley/Toeslope\"/>' + \\\n    '<ColorMapEntry color=\"#b671f2\" quantity=\"39\" label=\"Moist Flats\"/>' + \\\n    '<ColorMapEntry color=\"#08a702\" quantity=\"43\" label=\"Cool Footslope/Cove\"/>' + \\\n    '<ColorMapEntry color=\"#0a7000\" quantity=\"44\" label=\"Warm Footslope/Cove\"/>' + \\\n  '</ColorMap>' + \\\n'</RasterSymbolizer>')\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe o asset\n\nvariedade = ee.Image(\"projects/ee-lucasljardim9/assets/landform_types\")\n\n# Plote o mapa\n\nMap.addLayer(variedade.sldStyle(sld_intervals)) \n\n\nMap\n```\n\n","srcMarkdownNoYaml":"\n\n\n\n## Importando pacotes e inicializando *geemap*\n\n```{python}\nimport os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n```\n\n```{python}\ngeemap.ee_initialize()\n```\n\n## Classificando as formas do relevo\n\n### Formas do relevo\n\nUtilizamos a metodologia proposta por @anderson_resilient_2016 para definir as formas de relevo (do inglês, *landforms*). As formas de relevo geradas foram: \n\n\n* **3 - Cool Steep Slope**\n* **4 - Warms Steep Slope**\n* **5 - Cliff**\n* **11 - Summit/Ridgetop**\n* **13 - Slope Crest**\n* **21 - Flat Hilltop**\n* **22 - Gentle Slope Hilltop**\n* **23 - Cool Sideslope**\n* **24 - Warm Sideslope**\n* **30 - Dry Flats**\n* **32 - Valley/Toeslope**\n* **39 - Moist Flats**\n* **43 - Cool Footslope**\n* **44 - Warm Sideslope**\n\n### Variáveis classificadoras das formas de relevo\n\nAs variáveis utilizadas para calcular as formas de relevo foram: **declividade** (*slope*), **exposição** (*aspect*), **Índice de Posição Topográfica** (*TPI*, do inglês *Topographic Position Index*) e **índice de umidade** (*moisture index*). As formas de relevo são classificadas principalmente por declividade e TPI (Figura 1). A exposição classifica as faces *quentes* ou *frias* do relevo e o índice de umidade classifica as áreas planas em secas ou úmidas. \n\n![](figura/landform_scheme.png)\n\n    Figura 1. Classificação das formas de relevo pela declividade, exposição, índice de posição topográfica e índice de umidade. Adaptação de @anderson_resilient_2016.\n    \n\nAs variáveis foram discretizadas em classes e combinadas para comporem os tipos de formas de relevo. Os limiares utilizados para a discretização (Tabela 1) foram definidos por ajustes visuais que melhor representavam as formas de relevo.\n\n\n               Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n| Variável| Classe | Limiar inferior | Limiar superior |\n|:-:|:-:|:-:|:-:|\n|Declividade|1|-1|2|\n|Declividade|2|2|6|\n|Declividade|3|6|24|\n|Declividade|4|24|35|\n|Declividade|5|35|90|\n|TPI|1|-Inf|-15|\n|TPI|2|-15|-1|\n|TPI|3|-1|30|\n|TPI|4|30|975|\n|Exposição|2|0|90|\n|Exposição|1|90|270|\n|Exposição|2|270|360|\n|Índice de umidade|0|-Inf|30000|\n|Índice de umidade|1|3000|Inf|\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de índice de umidade, 2 de exposição, 3 de TPI e 1 de declividade. Posteriormente, os valores finais foram convertidos em tipos de formas de relevo, seguindo a classificação indicada na Tabela 2.\n\n    Tabela 2. Tabela 2. Critério de conversão dos códigos da combinação de classes em tipos de formas de relevo.\n    \n|Código|Formas de relevo|\n|:-:|:-:|\n|10|11|\n|11|11|\n|12|11|\n|13|13|\n|14|11|\n|15|5|\n|20|21|\n|21|21|\n|22|22|\n|23|24|\n|24|24|\n|25|5|\n|31|30|\n|32|32|\n|33|24|\n|34|24|\n|35|5|\n|40|32|\n|41|32|\n|42|32|\n|43|43|\n|44|3|\n|45|5|\n|51|51|\n|111|11|\n|112|11|\n|113|13|\n|114|3|\n|115|5|\n|121|21|\n|122|22|\n|123|23|\n|124|3|\n|125|5|\n|131|30|\n|132|32|\n|133|23|\n|134|3|\n|135|5|\n|141|32|\n|142|32|\n|143|43|\n|144|3|\n|145|5|\n|151|51|\n|211|11|\n|212|11|\n|213|13|\n|214|4|\n|215|5|\n|221|21|\n|222|22|\n|223|24|\n|224|4|\n|225|5|\n|231|30|\n|232|32|\n|233|24|\n|234|4|\n|235|5|\n|241|32|\n|242|32|\n|243|44|\n|244|4|\n|245|5|\n|251|51|\n|1000|39| \n\n## Cálculo da variedade de formas de relevo\n\n### Bases de dados\n\nClassificamos as formas de relevo utilizando o Modelo Digital de Elevação (DEM) do Merit-DEM [@yamazaki_high-accuracy_2017], o acúmulo de fluxo do Merit-Hydro [@yamazaki_merit_2019] e a camada de uso do solo do MapBiomas [@mapbiomas_project_collection_2020]. O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do *Shuttle Radar Topography Mission* (SRTM) [@farr_shuttle_2007] e *Advanced Land Observing Satellite* (ALOS) [@tadono_t_precise_2014], permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como *speckle noise*, *stripe noise*, *absolute bias* e *tree height bias* [@yamazaki_high-accuracy_2017]. A correção de *tree height bias* é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\n\nIncluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto. \n\n## Códigos para a criação da variedade de formas do relevo\n\nAs análises foram rodadas no *Google Earth Engine* [@gorelick_google_2017], devido a demanda computacional do projeto, usando o pacote **geemap** [@wu_geemap_2020] em *Python* [@python_software_foundation_python_2023] como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para replicação da análise pode ser baixado em [https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb](https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb).\n\n### Declividade (*slope*)\n\nNós criamos a superfície de declividade a partir do Merit-DEM.\n\n```{python}\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando a declividade\n\nslope = ee.Terrain.slope(DEM)\n```\n\n### Exposição (*aspect*)\n\nNós calculamos a exposição do relevo utilizando o mesmo DEM.\n\n```{python}\naspect = ee.Terrain.aspect(DEM)\n```\n\n### Índice de Posição Topográfica (TPI)\n\nNós calculamos o Índice de Posição Topográfica (TPI)[@weiss_topographic_2001] para cada célula do *raster* dentro de um *kernel* circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\n$TPI = \\frac{\\sum_{i}^{n}(vizinhança_i -  focal)}{n}$\n\na vizinhança *i* representa cada uma das *n* células dentro do *kernel* da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional [@theobald_ecologically-relevant_2015]. Os tamanhos das janelas foram definidos visualmente para que melhor representassem as formas do relevo, principalmente os *Summits*, *Valleys*, *Toeslopes* e *Hilltops* (*flat* e *gentle*). Os tamanhos das janelas também tinham que capturar os platôs das Chapadas como *Summits*. \n\n```{python}\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n```\n\n```{python}\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n```\n\n### Índice de umidade (*Moisture index*)\n\nNós calculamos o índice de umidade [@anderson_resilient_2016] baseado no acúmulo de fluxo presente no Merit-Hydro [@yamazaki_merit_2019], na camada **upg**, que é calculado sobre o Merit-DEM. O índice de umidade é calculado da seguinte forma:\n\n$moisture.index = \\frac{\\log(fluxo + 1)}{(declividade + 1)} \\times 1000$\n\nonde ***fluxo*** é o acúmulo de fluxo e ***declividade*** é a calculada anteriormente. O índice de umidade é a média do índice dentro de um *kernel* circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d'água.\n\n```{python}\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o índice de umidade\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)\n```\n\n## Convertendo variáveis em classes\n\n### Declividade (*slope*)\n\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo [@anderson_resilient_2016]. As classes de declividade foram criadas com o seguinte código:\n\n```{python}\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n```\n\n### Exposição (*aspect*)\n\nA exposição foi escolhido para definir as faces quentes e frias no hemisfério sul.\n\n```{python}\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2) # face quente\n    .where(aspect.gt(90).And(aspect.lte(270)), 1) # face fria\n    .where(aspect.gt(270).And(aspect.lte(360)), 2) # face quente\n)\n```\n\n### Índice de Posição do Relevo (TPI)\n\nAs classes de TPI foram definidas para representarem bem os *Summits*, *Valleys*, *Toeslopes* e *Hilltops*, que foram as formas do relevo mais difíceis de ajustar os parâmetros.\n\n```{python}\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n```\n\n### Índice de Umidade (*moisture index*)\n\nO limiar do índice de umidade para classificar as áreas como umidas ou secas foi definido visualmente para capturar a distribuição dos cursos d'água sem criar áreas planas secas com excesso de ramificações dendríticas. Os grandes rios, represas e lagoas (ex. Rio Amazonas) não foram bem representados pelo índice de umidade, pois ele classificava somente as partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d'água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a classe de águas presente no MapBiomas.\n\n```{python}\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n```\n\n### Combinando as classes\n\nCombinamos as classes para gerar um código representativo de cada variável. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1.  \n\n```{python}\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n```\n\n### Classificando as formas do relevo\n\nClassificamos as formas do relevo pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as formas do relevo. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (*Summit*). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de formas de relevo como *Sideslopes* de *Valleys* e *Toeslopes*. \n\n```{python}\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n```\n\n### Exportando mapas para assets\n\n```{python}\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n```\n\n```{python}\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=regiao_box, scale=escala,maxPixels=1e13\n)\n```\n\n### Exemplo de formas de relevo\n\nAbaixo está uma representação das formas de relevo na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n```{python}\n%%capture --no-display\n#| echo: false\n\n# Delimitando a região\nbb = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=bb, file_per_band=False\n)\n```\n\n```{python}\n# Paleta de cores das formas de relevo\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n```\n\n          Figura 2. Formas de relevo classificadas na região de Alto Paraíso de Goiás-GO, Brasil.\n\n## Calculando a variedade de formas de relevo\n\nA variedade de formas do relevo foi calculada como a soma dos tipos de formas dentro de um *kernel* circular de uma célula focal. O tamanho do raio do *kernel* foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele no qual o raio subsequente não adicionou variedade. Dessa forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de formas do relevo. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de formas do relevo para a mesma região de Alto Paraíso de Goiás-GO.\n\n```{python}\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n```\n\n```{python}\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=bb, file_per_band=False\n)\n```\n\n```{python}\n#| scrolled: true\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n```\n\n            Figura 3. Variedade de formas de relevo para região de Alto Paraíso de Goiás-GO, Brasil.\n\n```{python}\n# modifique o assetId para o endereço do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,maxPixels=1e13\n)\n```\n\n## Conferir a criação do *asset* \n\nO *asset* pode demorar algumas horas para se criado. Para conferir se o *asset* foi criado, rode a linha de comando abaixo para buscar o nome do *asset* na nuvem do GEE. Se não funcionar confira [aqui](https://developers.google.com/earth-engine/guides/command_line) como instalar as funções para uso da linha de comando.\n\n```{python}\nos.system(f\"earthengine ls projects/ee-lucasljardim9/assets| grep 'assets/landform_variety'\")\n```\n\nOutra possibilidade é acessar a página do [editor de código](https://code.earthengine.google.com) do GEE e na parte direita da tela, em **Tasks** confira se o processo de criação finalizou com sucesso, colorido em azul. Vermelho indica que houve algum erro durante o processo.  \n\n\n![](figura/tasks.png)\n\nTambém é possível ver os *assets* na aba **Assets**, na parte esquerda da tela.\n\n![](figura/asset.png)\n\nVeja o dado criado com:\n\n```{python}\n# Paleta de cores\nsld_intervals =(\n'<RasterSymbolizer>' + \\\n  '<ColorMap type=\"intervals\" extended=\"False\">' + \\\n    '<ColorMapEntry color=\"#ffc408\" quantity=\"3\" label=\"Cool Steep Slope\"/>' + \\\n    '<ColorMapEntry color=\"#ffa101\" quantity=\"4\" label=\"Warm Steep Slope\"/>' + \\\n    '<ColorMapEntry color=\"#ef595a\" quantity=\"5\" label=\"Cliff\"/>' + \\\n    '<ColorMapEntry color=\"#ffbdbe\" quantity=\"11\" label=\"Summit/Ridgetop\"/>' + \\\n    '<ColorMapEntry color=\"#6e4100\" quantity=\"13\" label=\"Slope Crest\"/>' + \\\n    '<ColorMapEntry color=\"#af7b53\" quantity=\"21\" label=\"Flat Hilltop\"/>' + \\\n    '<ColorMapEntry color=\"#c8c284\" quantity=\"22\" label=\"Gentle Slope Hilltop\"/>' + \\\n    '<ColorMapEntry color=\"#c8f6ad\" quantity=\"23\" label=\"Cool Sideslope\"/>' + \\\n    '<ColorMapEntry color=\"#83e763\" quantity=\"24\" label=\"Warm Sideslope\"/>' + \\\n    '<ColorMapEntry color=\"#ffffbe\" quantity=\"30\" label=\"Dry Flats\"/>' + \\\n    '<ColorMapEntry color=\"#a9a800\" quantity=\"32\" label=\"Valley/Toeslope\"/>' + \\\n    '<ColorMapEntry color=\"#b671f2\" quantity=\"39\" label=\"Moist Flats\"/>' + \\\n    '<ColorMapEntry color=\"#08a702\" quantity=\"43\" label=\"Cool Footslope/Cove\"/>' + \\\n    '<ColorMapEntry color=\"#0a7000\" quantity=\"44\" label=\"Warm Footslope/Cove\"/>' + \\\n  '</ColorMap>' + \\\n'</RasterSymbolizer>')\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe o asset\n\nvariedade = ee.Image(\"projects/ee-lucasljardim9/assets/landform_types\")\n\n# Plote o mapa\n\nMap.addLayer(variedade.sldStyle(sld_intervals)) \n\n\nMap\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"output-file":"1_landforms.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjetura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente"},"metadata":{"lang":"pt-br","fig-responsive":true,"quarto-version":"1.3.340","bibliography":["bibliografia.bib"],"csl":"citation_style.csl","theme":"default","title":"Variedade de formas do relevo","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}