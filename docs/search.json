[
  {
    "objectID": "1_landforms.html",
    "href": "1_landforms.html",
    "title": "Variedade de formas do relevo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "1_landforms.html#importando-pacotes-e-inicializando-geemap",
    "href": "1_landforms.html#importando-pacotes-e-inicializando-geemap",
    "title": "Variedade de formas do relevo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "1_landforms.html#bases-de-dados",
    "href": "1_landforms.html#bases-de-dados",
    "title": "Variedade de Landforms",
    "section": "Bases de dados",
    "text": "Bases de dados\nNós utilizamos para a classificação das landforms o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), o acúmulo de fluxo do Merit-Hydro (Yamazaki et al. 2019) e a camada de uso do solo do MapBiomas (MapBiomas Project 2020). O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\nNós incluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto."
  },
  {
    "objectID": "1_landforms.html#códigos-para-a-criação-da-variedade-de-landforms",
    "href": "1_landforms.html#códigos-para-a-criação-da-variedade-de-landforms",
    "title": "Variedade de Landforms",
    "section": "Códigos para a criação da variedade de landforms",
    "text": "Códigos para a criação da variedade de landforms\nNossas análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\n\nInclinação do relevo (slope)\nNós criamos a superfície de slope a partir do Merit-DEM.\n\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando o slope\n\nslope = ee.Terrain.slope(DEM)\n\n\n\nAspecto (aspect)\nNós calculamos o aspect do relevo utilizando o mesmo DEM.\n\naspect = ee.Terrain.aspect(DEM)\n\n\n\nÍndice de Posição Topográfica (TPI)\nNós calculamos o Índice de Posição Topográfica (TPI)(Weiss 2001) para cada célula do raster dentro de um kernel circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\\(TPI = \\frac{\\sum_{i}^{n}(vizinhança_i - focal)}{n}\\)\na vizinhança i representa cada uma das n células dentro do kernel da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional (Theobald et al. 2015). Os tamanhos das janelas foram definidos visualmente para que melhor representassem as landforms, principalmente os Summits, Valleys, Toeslopes e Hilltops (flat e gentle). Os tamanhos das janelas também tinham que capturar os Platôs como Summits.\n\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n\n\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n\n\n\nÍndice de Umidade (Moisture index)\nNós calculamos o moisture index (Anderson et al. 2016) baseado no acúmulo de fluxo presente no Merit-Hydro (Yamazaki et al. 2019), na camada upg, que é calculado sobre o Merit-DEM. O moisture index é calculado da seguinte forma:\n\\(moisture.index = \\frac{\\log(fluxo + 1)}{(slope + 1)} \\times 1000\\)\nonde fluxo é o acúmulo de fluxo e slope é o slope calculado anteriormente. O moisture index é a média do índice dentro de um kernel circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d’água.\n\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o moisture index\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)\n\n\n\nConvertendo variáveis em classes\n\n\nInclinação do relevo (slope)\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo Anderson et al. (2016). As classes de slope foram criadas com o seguinte código:\n\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n\n\n\nAspecto (aspect)\nO aspecto foi escolhido para definir as faces norte e sul do relevo no hemisfério sul.\n\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2)\n    .where(aspect.gt(90).And(aspect.lte(270)), 1)\n    .where(aspect.gt(270).And(aspect.lte(360)), 2)\n)\n\n\n\nÍndice de Posição do Relevo (TPI)\nAs classes de TPI foram definidas para representarem bem os Summits, Valleys, Toeslopes e Hilltops, que foram as landforms mais difíceis de ajustar os parâmetros.\n\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n\n\n\nÍndice de Umidade (moisture index)\nO limiar do índice umidade para classificar as áreas como umidas ou secas foram definidos visualmente para capturarem a distribuição dos cursos d’água sem criar áreas planas secas com excesso de ramificações dendríticas. Grandes rios (ex. Rio Amazonas, represas e lagos) não foram bem representados pelo moisture index, pois classificava somente a partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d’água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a camada de águas produzida pelo MapBiomas.\n\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n\n\n\nCombinando as classes\nCombinamos as classes para a geração de um código representativo de cada variável. O moisture index foi multiplicado por 1000, aspect por 100, TPI por 10 e slope por 1.\n\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n\n\n\nClassificando os tipos de landforms\nClassificamos os tipos de landforms pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as landforms. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (Summit). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de landforms como Sideslopes de Valleys e Toeslopes.\n\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n\n\n\nExportando mapas para assets\n\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n\n\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=bioma_box, scale=escala,maxPixels=1e13\n)\n\n\n\nExemplo de landforms\nAbaixo está uma representação das landforms na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n%%capture --no-display\n#| echo: false\n\n# Delimitando a região\nregiao = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=regiao, file_per_band=False\n)\n\n\n# Paleta de cores das landforms\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n\n      Figura 2. Landforms classificadas na região de Alto Paraíso de Goiás-GO, Brasil."
  },
  {
    "objectID": "1_landforms.html#calculando-a-variedade-de-landforms",
    "href": "1_landforms.html#calculando-a-variedade-de-landforms",
    "title": "Variedade de Landforms",
    "section": "Calculando a variedade de landforms",
    "text": "Calculando a variedade de landforms\nA variedade de landforms foi calculada como a soma de tipos diferentes de landforms dentro de um kernel circular de uma célula focal. O tamanho do raio do kernel foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele que o subsequente não adicionou variedade. Desta forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de landforms. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de landforms para a mesma região de Alto Paraíso de Goiás-GO.\n\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n\n\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=regiao, file_per_band=False\n)\n\n\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n\n        Figura 3. Variedade de landforms para região de Alto Paraíso de Goiás-GO, Brasil.\n\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=bioma_box, \n    scale=escala,maxPixels=1e13\n)"
  },
  {
    "objectID": "1_landforms.html#bibliografia",
    "href": "1_landforms.html#bibliografia",
    "title": "Variedade de formas do relevo",
    "section": "Bibliografia",
    "text": "Bibliografia\nAnderson, M.G., Barnett, A., Clark, M., Ferree, C., Sheldon, A.O., Prince, J. 2016. Resilient Sites for Terrestrial Conservation in Eastern North America. The Nature Conservancy. http://easterndivision.s3.amazonaws.com/Resilient_Sites_for_Terrestrial_Conservation.pdf.\nFarr, T.G., et al. 2007. The shuttle radar topography mission. Reviews of Geophysics, 45, 2, RG2004, https://doi.org/10.1029/2005RG000183.\nGorelick, N., Hancher, M., Dixon, M., Ilyushchenko, S., Thau, D., Moore, R. 2017. Google Earth Engine: Planetary-scale geospatial analysis for everyone. Remote Sensing of Environment, 202, 18-27, https://doi.org/10.1016/j.rse.2017.06.031.\nMapBiomas Project. 2020. Collection 7 of the Annual Series of Land Use and Land Cover Maps of Brazil. Accessed on 2023 through the link: projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2.\nPython Software Foundation. Python Language Reference. http://www.python.org.\nTadono, T., Ishida, H., Oda, F., Naito, S., Minakawa, K., Iwamoto, H. 2014. Precise Global DEM Generation by ALOS PRISM. Precise Global DEM Generation by ALOS PRISM. ISPRS Annals of the Photogrammetry, Remote Sensing and Spatial Information Sciences, II-4, 71–76, https://doi.org/10.5194/isprsannals-ii-4-71-2014.\nTheobald, D.M., Harrison-Atlas, D., Monahan, W.B., Albano, C.M. 2015. Ecologically-relevant maps of landforms and physiographic diversity for climate adaptation planning. Plos One, 12, 1-17, https://doi.org/10.1371/journal.pone.0143619.\nYamazaki, D., Ikeshima, D., Tawatari, R., Yamaguchi, T, O’Loughlin, F., Neal, J.C., Sampson, C.C., Kanae, S., Bates, P.D. 2017. A high-accuracy map of global terrain elevations. Geophysical Research Letters, 11, 5844-5853, doi:10.1002/2017GL072874.\nYamazaki, D., Ikeshima, D., Sosa, J., Bates, Paul, D., Allen, G.H., Pavelsky, T.M. 2019. MERIT Hydro: A High-Resolution Global Hydrography Map Based on Latest Topography Dataset. Water Resources Research, 6, 5053-5073, https://doi.org/10.1029/2019WR024873.\nIwahashi, J., Yamazaki, D. 2022. Global polygons for terrain classification divided into uniform slopes and basins. Progress in Earth and Planetary Science, 9, 33, https://doi.org/10.1186/s40645-022-00487-2.\nWeiss, A.D., 2001. Topographic position and landforms analysis. Poster Presentation, ESRI Users Conference, San Diego, CA.\nWu, Q. 2020. geemap: A Python package for interactive mapping with Google. Journal of Open Source Software, 5, 51, 2305, https://doi.org/10.21105/joss.02305."
  },
  {
    "objectID": "2_elevation_range.html",
    "href": "2_elevation_range.html",
    "title": "Amplitude altitudinal",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "2_elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "href": "2_elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "title": "Amplitude altitudinal",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "2_elevation_range.html#base-de-dados",
    "href": "2_elevation_range.html#base-de-dados",
    "title": "Amplitude altitudinal",
    "section": "Base de dados",
    "text": "Base de dados\nUtilizamos o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), na escala de 90 metros. O Merit-DEM é um produto global que combina dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono, T. et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. Além disso, o Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é especialmente importante para a Floresta Amazônica devido à sua densidade de árvores altas.\nA variedade de formas de relevo foi calculada anteriormente (veja o capítulo Variedade de formas de relevo) e está disponível como um asset em https://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landform_variety.\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido à demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/2_elevation_range.ipynb."
  },
  {
    "objectID": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-de-elevação-residual",
    "href": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-de-elevação-residual",
    "title": "Amplitude de Elevação",
    "section": "Códigos para o cálculo da amplitude de elevação residual",
    "text": "Códigos para o cálculo da amplitude de elevação residual\nNossas análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\nNós importamos os rasters do modelo digital de elevação e da variedade de landforms.\n\n# Importando o modelo digital de elevação\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# Importando a variedade de landforms calculada anteriormente\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\n#Escala dos rasters ~92 metros\nescala = DEM.projection().nominalScale()\n\nNós extraímos do raster as células dentro da vizinhança (kernel circular com 5 células de raio, ~450 metros) da célula focal e salvamos como bandas de uma imagem. Assim, cada banda é um stack das células da vizinhança da célula focal, a primeira banda possui todas as primeiras células de cada célula focal, a segunda banda todas as segunda células e assim por diante.\n\n# Tamanho do raio do kernel para o calculo da amplitude de elevação\nradius_pixels = 5\n\n# Criando rasters da vizinhança de cada célula como bandas da imagem\nneighbor = DEM.neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels)))\n\nA imagem neighbor criada anteriormente as células da vizinhança como bandas da imagem. Assim, as primeiras células de cada banda são as células da vizinhança da primeira célula focal, organizadas como colunas (bandas). Ao calcularmos os valores máximos e mínimos para cada coluna de neighbor, estamos calculando os valores máximos e mínimos da vizinhança de cada célula focal.\n\n# Calcule o máximo da vizinhança\nelevation_max = neighbor.reduce(ee.Reducer.max())\n\n# Calcule o mínimo da vizinhança\nelevation_min = neighbor.reduce(ee.Reducer.min())\n\nSubtraindo os valores máximos e mínimos de cada célula focal e calculando o seu valor absoluto, temos a amplitude de elevação para cada célula focal. Nós salvamos a amplitude de elevação e variedade de landforms como uma imagem com duas bandas, sendo a primeira banda a variável preditora da regressão e a segunda banda a variável resposta.\n\n# Calcule a amplitude da vizinhança\nelevation_range = elevation_max.subtract(elevation_min).abs()\n\n# Crie uma imagem com as bandas de varidedade de landforms e amplitude de elevação \n# A primeira imagem é o x da regressão e a segunda é o y\n\nelevation = (ee.Image.cat(landform_variety, elevation_range)\n            .rename(['landform_variety', 'elevation_range']))\n\nDesta forma, aplicamos a regressão entre as variáveis.\n\n# Rode uma regressão linear (OLS) entre varidade de landforms e amplitude de elevação\nregression = elevation.reduceRegion(**{\n     'reducer': ee.Reducer.linearFit(),\n     'geometry': bioma_box,\n     'maxPixels': 1e13,\n     'scale': escala\n    })\n\nApós a regressão, multiplicamos a variável preditora pelo coeficiente de regressão (slope) e adicionamos o valor do intercepto para predizermos os valores de amplitude de elevação esperados pela regressão. Em seguida, subtraimos os valores de amplitude de elevação pelos valores preditos pela regressão para calcularmos os resíduos do modelo.\n\n# Calcule o valor predito, pela regressão, de amplitude elevação, sem intercepto \npred = elevation.select('landform_variety').multiply(ee.Number(regression.get('scale')))\n\n# Adicione o intercepto na predição\npredict = pred.add(ee.Number(regression.get('offset')))\n\n# Calcule o residuo da regressão\nresiduals = elevation.select('elevation_range').subtract(predict).rename(['residuals'])\n\nPor fim, exportamos o raster de amplitude de elevação residual como um asset do Google Earth Engine.\n\n# Exporte a amplitude de elevação residual como asset\nassetId = \"projects/ee-lucasljardim9/assets/elevation_range_residual\"\n\ngeemap.ee_export_image_to_asset(\n    residuals, \n    description='elevation_range_residual', \n    assetId=assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  },
  {
    "objectID": "3_wetland_score.html",
    "href": "3_wetland_score.html",
    "title": "Índice de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nO índice de áreas úmidas é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. O índice de áreas úmidas entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de formas de relevo e baixa amplitude altitudinal. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente (Anderson et al. 2016).\nExistem três cenários de distribuição de áreas úmidas:\n\n\nOs locais estão presentes em áreas com alta densidade de áreas úmidas no entorno,\n\n\nOs locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente,\n\n\nOs locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial.\n\n\nDessa forma, o índice de áreas úmidas é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local) (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNeste capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e no capítulo Z_scores mostraremos como calculamos os valores de Z e o índice de áreas úmidas."
  },
  {
    "objectID": "3_wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "href": "3_wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "title": "Índice de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nO índice de áreas úmidas é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. O índice de áreas úmidas entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de formas de relevo e baixa amplitude altitudinal. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente (Anderson et al. 2016).\nExistem três cenários de distribuição de áreas úmidas:\n\n\nOs locais estão presentes em áreas com alta densidade de áreas úmidas no entorno,\n\n\nOs locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente,\n\n\nOs locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial.\n\n\nDessa forma, o índice de áreas úmidas é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local) (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNeste capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e no capítulo Z_scores mostraremos como calculamos os valores de Z e o índice de áreas úmidas."
  },
  {
    "objectID": "3_wetland_score.html#banco-de-dados",
    "href": "3_wetland_score.html#banco-de-dados",
    "title": "Índice de áreas úmidas",
    "section": "Banco de dados",
    "text": "Banco de dados\nUtilizamos como base de dados de áreas úmidas o Global Wetlands database (Gumbricht et al. 2017). Reprojetamos o raster de áreas úmidas para a mesma resolução do modelo digital de elevação usado nas etapas anteriores (~ 92 metros).\nRetiramos as áreas úmidas classificadas como sistemas lacustres e ribeirinhos (riverines e lacustrines) e reclassificamos o raster como sendo área úmida (1) ou não sendo área úmida (0). Depois, calculamos a densidade de áreas úmidas dentro de uma vizinhaça de 450 metros (5 células) de raio de um kernel circular (densidade local). Calculamos também a densidade e a quantidade de áreas úmidas na vizinhança de ~ 1170 metros (13 células) (regional)."
  },
  {
    "objectID": "3_wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "href": "3_wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "title": "Índice de áreas úmidas",
    "section": "Código para calcular as densidades e quantidade de áreas úmidas",
    "text": "Código para calcular as densidades e quantidade de áreas úmidas\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/3_wetland_score.ipynb.\nPrimeiro, nós importamos os polígonos dos biomas do Brasil e extraímos suas coordenadas geográficas máximas e mínimas para delimitar a região de análise. Importamos o modelo digital de elevação e o raster de áreas úmidas e reprojetamos a resolução das áreas úmidas para a resolução do modelo digital de elevação.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas \n# mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\n# Reprojetando áreas úmidas\nwetlands = (ee.Image(\"projects/ee-lucasljardim9/assets/Cifor_wetlands\") \n            .reproject(**{'crs': \"EPSG:4326\",\n                       'scale': escala}))\n\nEm seguida, retiramos os sistemas ribeirinhos e lacustres do raster de áreas úmidas e reclassificamos as classes do raster em presença e ausência de áreas úmidas.\n\n# Criando uma máscara para rios e lagos\n\nrivers = wetlands.mask(wetlands.neq(10))\n\n# Retirando rios e lagos das áreas úmidas\n\nwetlands = wetlands.mask(rivers)\n\n# Transformando áreas úmidas em um raster binário\n# de presença de áreas úmidas\n\nwetlands_binary = wetlands.where(wetlands.gt(0), 1).unmask()\n\nPosteriomente, calculamos a densidade de áreas úmidas, localmente, dentro de um kernel circular de ~450 metros (5 células). Primeiro, transformamos as células da vizinhança de cada célula focal em bandas de uma imagem. Assim, cada células vizinha da célula focal fica empilhada como uma coluna. Para cada coluna, somamos os valores das células (0 ou 1) como a quantidade de áreas úmidas na vizinhança. Depois, dividimos a quantidade de áreas úmidas pelo número de células na vizinhança, resultando na densidade de áreas úmidas.\n\nradius_pixels = 5\n\n# Tranforme as células da vizinha em bandas\n\nneighbors = (wetlands_binary\n            .neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels))))\n\n# Conte a quantidade de áreas úmidas na vizinhança\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\n\nneighbors_amount = neighbors.bandNames().length()\n\n#Divida a quantidade de áreas úmidas pelo \n# número de células para calcular a densidade \nwetlands_density_local = wetlands_count.divide(ee.Number(neighbors_amount))\n\nRepetimos o mesmo procedimento conduzido para a densidade local para calcularmos a densidade e quantidade de áreas úmidas regional.\n\nradius_pixels = 13\n\n# Transforme as células vizinhas em bandas\n\nneighbors = (wetlands_binary\n           .neighborhoodToBands(ee.Kernel.circle(\n                                   ee.Number(radius_pixels)\n                                   )\n                               ))\n\n# Conte a quantidade de áreas úmidas\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\nneighbors_amount = neighbors.bandNames().length()\n\n# Calcule a densidade dividindo a quantidade \n# de áreas úmidas pelo número de células\nwetlands_density_regional = wetlands_count.divide(ee.Number(neighbors_amount))\n\nPor fim, exportamos a densidade de áreas úmidas local (wetlands_density), a densidade regional (wetlands_density_1000) e a quantidade regional (wetlands_count) como assets no Google Earth Engine.\n\n# modifique os assetIds para os do seu projeto\n\nassetId_quantidade = \"projects/ee-lucasljardim9/assets/wetlands_count\"\n\nassetId_densidade_local = \"projects/ee-lucasljardim9/assets/wetlands_density\"\n\nassetId_densidade_regional = \"projects/ee-lucasljardim9/assets/wetlands_density_1000\"\n\ngeemap.ee_export_image_to_asset(\n    wetlands_count, \n    description='wetlands_count', \n    assetId=assetId_quantidade, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_local, \n    description='wetlands_density_local', \n    assetId=assetId_densidade_local, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_regional, \n    description='wetlands_density_regional', \n    assetId=assetId_densidade_regional, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)"
  },
  {
    "objectID": "4_soil_diversity.html",
    "href": "4_soil_diversity.html",
    "title": "Riqueza de solos",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA riqueza de solos é calculada como a quantidade de componentes da unidade de mapeamento de solos."
  },
  {
    "objectID": "4_soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "href": "4_soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Riqueza de solos",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA riqueza de solos é calculada como a quantidade de componentes da unidade de mapeamento de solos."
  },
  {
    "objectID": "4_soil_diversity.html#banda-de-dados",
    "href": "4_soil_diversity.html#banda-de-dados",
    "title": "Riqueza de solo",
    "section": "Banda de Dados",
    "text": "Banda de Dados\nNós utilizamos a base de dados de pedologia do Instituto Brasileiro de Geografia e Estatística (IBGE) como base para o cálculo da riqueza de solos. Calculamos a quantidade de solos componentes de cada polígono e rasterizados na escala do modelo digital de elevação que usamos nas etapas anteriores (~ 90 metros)."
  },
  {
    "objectID": "4_soil_diversity.html#códigos-para-a-criação-da-diversidade-de-solos",
    "href": "4_soil_diversity.html#códigos-para-a-criação-da-diversidade-de-solos",
    "title": "Riqueza de solo",
    "section": "Códigos para a criação da diversidade de solos",
    "text": "Códigos para a criação da diversidade de solos\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020), em Python (Python Software Foundation 2023), como interface pela facilidade na documentação e reprodutividade das análises.\nO primeiro passo é criar uma função que conta os tipos de solos componentes de cada polígono. Concatenamos as colunas componente, component1, component2 e component3. Depois, separamos a string pelos sinais de “+”, que indicam as separações das descrições de cada tipo de solo. Em seguida, contamos quantos tipo de solos existem em cada polígono como o comprimento da lista de tipos de solos. Adicionamos uma coluna chamada soil_richness com a riqueza de solos em cada polígono.\n\ndef fun(feature):\n    number = (ee.String(feature.get(\"componente\"))\n              .cat(ee.String(feature.get(\"component1\")))\n              .cat(ee.String(feature.get(\"component2\")))\n              .cat(ee.String(feature.get(\"component3\")))\n              .split(\"\\+\")\n              .length())\n\n    return feature.set(\"soil_richness\", number)\n\nEm seguida, importamos os dados de solo, definimos a região para exportar o dado e a escala da análise.\n\n# Importando os polígonos de solo\nsolo = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/pedo_area\")\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\nAplicamos a função criada anteriormente aos polígonos de solo\n\nsolo = solo.map(fun)\n\nRasterizamos a riqueza de solos na mesma escala das análises anteriores (~90 metros).\n\nsoil_diversity = solo.reduceToImage(**{'properties':[\"soil_richness\"],\n                     'reducer':ee.Reducer.max()}) \\\n                     .reproject(**{'crs':\"EPSG:4326\",\n                                  'scale':escala})\n\nPor fim, exportamos o raster como um asset no Google Earth Engine.\n\n# Exporte o raster de diversidade de solo \nassetId = \"projects/ee-lucasljardim9/assets/soil_diversity\"\n\ngeemap.ee_export_image_to_asset(\n    soil_diversity, description='soil_diversity', assetId=assetId, region=regiao_box, scale=escala, maxPixels=1e13\n)"
  },
  {
    "objectID": "5_Z_scores.html",
    "href": "5_Z_scores.html",
    "title": "Valor de Z das variáveis",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\ngeemap.ee_initialize()"
  },
  {
    "objectID": "5_Z_scores.html#base-de-dados",
    "href": "5_Z_scores.html#base-de-dados",
    "title": "Valor de Z das variáveis",
    "section": "Base de dados",
    "text": "Base de dados\nUtilizamos as variáveis criadas anteriormente e guardadas como assets no Google Earth Engine. As variáveis são:\n\nvariedade de formas de relevo\namplitude altitudinal\nriqueza de solo\ndensidade local de áreas úmidas\ndensidade regional de áreas úmidas\nquantidade regional de áreas úmidas"
  },
  {
    "objectID": "5_Z_scores.html#códigos-para-o-cálculo-dos-z-scores",
    "href": "5_Z_scores.html#códigos-para-o-cálculo-dos-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Códigos para o cálculo dos Z-scores",
    "text": "Códigos para o cálculo dos Z-scores\nAs análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\nPrimeiro, nós criamos uma função para calcular o Z-score dentro de cada janela móvel (code) para cada variável (image). A função calcula a média e desvio padrão para a vizinhança de cada célula, utilizando uma janela móvel circular. Depois, os valores e média e desvio padrão convertidos para Z-score pela subtração variável pela média e divida pelo desvio padrão.\n\ndef calculate_Z_scores(image, windows):\n\n  # Calculating the mean\n  mean = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.mean(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Calculating the standard deviation\n  sd = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.stdDev(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Values as a raster\n  meanValue = mean.rename('mean')\n  sdValue = sd.rename('sd')\n\n  # Calculating the z scores\n  z = image.subtract(meanValue).divide(sdValue).rename('z')\n\n  return z\n\nAqui nós importamos as variáveis de interesse para o cálculo de Z.\n\n# Importando as variáveis\n\n#Conferir os links\n\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/elevation_range_residual\")\n\nsoil_diversity = ee.Image('projects/ee-lucasljardim9/assets/soil_diversity')\n\nconnectedness = ee.Image(\"projects/ee-lucasljardim9/assets/Biomas_resistencia_kernel\")\n\n# Importando os dados de wetlands para o wetland score\n\nwetlands_count = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_count\")\n\nwetlands_density = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density\")\n\nwetlands_density_1000 = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density_1000\")\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()"
  },
  {
    "objectID": "5_Z_scores.html#calculando-z-scores",
    "href": "5_Z_scores.html#calculando-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Calculando Z-scores",
    "text": "Calculando Z-scores\nNós aplicamos a função wrap_calculate_Z para cada variável e guardamos o valores de Z calculados.\n\n# Calculando os valores de Z para cada variável\n\nwindows = 200\n\nZ_landform_variety = calculate_Z_scores(landform_variety, windows)\n\nZ_elevation_range = calculate_Z_scores(elevation_range, windows)\n\nZ_soil_diversity = calculate_Z_scores(soil_diversity, windows)\n\nZ_wetlands_count = calculate_Z_scores(wetlands_count, windows)\n\nZ_wetlands_density = calculate_Z_scores(wetlands_density, windows)\n\nZ_wetlands_density_1000 = calculate_Z_scores(wetlands_density_1000, windows)\n\nZ_connectedness = calculate_Z_scores(connectedness, windows).multiply(-1)\n# conferir se precisar multiplicar mesmo po -1"
  },
  {
    "objectID": "5_Z_scores.html#calculando-wetland-score",
    "href": "5_Z_scores.html#calculando-wetland-score",
    "title": "Calculando Z-scores das variáveis",
    "section": "Calculando wetland score",
    "text": "Calculando wetland score\nAqui, nós calculamos o wetland score, aplicando a fórmula descrita anteriormente.\n\n# Calculando a densidade de areas úmidas como a média do local e regional\nwetlands_density = (Z_wetlands_density\n                    .multiply(2)\n                    .add(Z_wetlands_density_1000)\n                    .divide(3))\n\n# Testando se o Z da quantidade de áreas úmidas é maior que a densidade média\n\nwet_test = wetlands_density.lt(Z_wetlands_count)\n\n# Média de densidade local, regional e quantidade de áreas úmidas\nwet_average = (wetlands_density\n              .multiply(3)\n              .add(Z_wetlands_count)\n              .divide(4))\n\n# Substituindo os locais com densidade menor que a quantidade pelos valores de quantidade             \nZ_wetlands_score = Z_wetlands_density.where(wet_test, wet_average)"
  },
  {
    "objectID": "5_Z_scores.html#exportando-os-z-scores",
    "href": "5_Z_scores.html#exportando-os-z-scores",
    "title": "Calculando Z-scores das variáveis",
    "section": "Exportando os Z-scores",
    "text": "Exportando os Z-scores\nPor último, exportamos todas as imagens de Z como asset no Google Earth Engine.\n\n# Criando os links dos assets\nlandform_assetId = \"projects/ee-lucasljardim9/assets/Z_landform_variety\"\n\nelevation_assetId = \"projects/ee-lucasljardim9/assets/Z_elevation_range\"\n\nwetland_assetId = \"projects/ee-lucasljardim9/assets/Z_wetlands_score\"\n\nsoil_assetId = \"projects/ee-lucasljardim9/assets/Z_soil_diversity\"\n\nconnectedness_assetId = \"projects/ee-lucasljardim9/assets/Z_connectedness\"\n\n# Exportando as imagens\ngeemap.ee_export_image_to_asset(\n    Z_landform_variety, \n    description='Z_landform_variety', \n    assetId=landform_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_elevation_range, \n    description='Z_elevation_range', \n    assetId=elevation_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_wetlands_score, \n    description='Z_wetlands_score', \n    assetId=wetland_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_soil_diversity, \n    description='Z_soil_diversity', \n    assetId=soil_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_connectedness, \n    description='Z_connectedness', \n    assetId=connectedness_assetId, \n    region=bioma_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  },
  {
    "objectID": "6_landscape_diversity.html",
    "href": "6_landscape_diversity.html",
    "title": "Diversidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA diversidade da paisagem é uma métrica composta pelos valores de Z da variedade de landforms, amplitude altitudinal, wetland score e diversidade de solos. Inicialmente, a diversidade da paisage assume os valores de variedade de landforms. Nos locais onde a amplitude de elevação é maior que variedade de landforms, a diversidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de landforms. Locais onde wetland score é maior que a diversidade da paisagem calculada anteriormente, os valores são substituídos por wetland score. Na localidades onde a diversidade de solo é maior que a diversidade da paisagem, os valores são substituídos pela média ponderada das variáveis naquela localidade."
  },
  {
    "objectID": "6_landscape_diversity.html#importando-pacotes-e-inicializando-geemap",
    "href": "6_landscape_diversity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Diversidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA diversidade da paisagem é uma métrica composta pelos valores de Z da variedade de landforms, amplitude altitudinal, wetland score e diversidade de solos. Inicialmente, a diversidade da paisage assume os valores de variedade de landforms. Nos locais onde a amplitude de elevação é maior que variedade de landforms, a diversidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de landforms. Locais onde wetland score é maior que a diversidade da paisagem calculada anteriormente, os valores são substituídos por wetland score. Na localidades onde a diversidade de solo é maior que a diversidade da paisagem, os valores são substituídos pela média ponderada das variáveis naquela localidade."
  },
  {
    "objectID": "6_landscape_diversity.html#base-de-dados",
    "href": "6_landscape_diversity.html#base-de-dados",
    "title": "Diversidade da paisagem",
    "section": "Base de Dados",
    "text": "Base de Dados\nOs dados para a diversidade da paisagem são os criados na etapa de cálculo dos Z-scores, descrito anteriormente."
  },
  {
    "objectID": "6_landscape_diversity.html#códigos-para-a-criação-da-diversidade-da-paisagem",
    "href": "6_landscape_diversity.html#códigos-para-a-criação-da-diversidade-da-paisagem",
    "title": "Diversidade da paisagem",
    "section": "Códigos para a criação da diversidade da paisagem",
    "text": "Códigos para a criação da diversidade da paisagem\nNossas análises foram rodadas no Google Earth Engine (Gorelick 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises.\nNós importamos os dados de bioma para delimitar a região de análise e o raster do Brasil para que os mapas sejam cortados para o Brasil antes do cálculo da diversidadade da paisagem.\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nbioma = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\nbrasil_raster = ee.Image(\"projects/ee-lucasljardim9/assets/brasil_raster\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nbioma_box = bioma.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()\n\nImportamos os mapas e cortamos para o raster do Brasil.\n\n# Importando e cortando as imagens para o Brasil\nlandform_Z = (ee.Image('projects/ee-lucasljardim9/assets/Z_landform_variety')\n              .updateMask(brasil_raster))\n\nelevation_range_Z = (ee.Image('projects/ee-lucasljardim9/assets/Z_elevation_range')\n                     .updateMask(brasil_raster))\n\nwetland_score = (ee.Image('projects/ee-lucasljardim9/assets/Z_wetlands_score')\n                 .updateMask(brasil_raster))\n\nsoil_diversity =  (ee.Image('projects/ee-lucasljardim9/assets/Z_soil_diversity')\n                   .updateMask(brasil_raster))\n\nAqui começamos o cálculo da diversidade da paisagem, atribuindo à diversidade da paisagem os valores de variedade de landforms. Depois testamos os locais onde a amplitude de elevação é maior que a variedade de landforms e substituímos os valores.\n\nlandscape_diversity = landform_Z\n\n# Testando se o Z da amplitude de elevação é maior que o Z da variedade de landsforms\ntest_1 = elevation_range_Z.gt(landscape_diversity)\n\n# Média ponderada entre variedade de landforms e amplitude de elevação\naverage_elevation = landform_Z.multiply(2).add(elevation_range_Z).divide(3)\n\n# Substituindo os valores de variedade de landforms por amplitude de elevação \n# onde o segundo valor é maior que o primeiro\nlandscape_diversity = landscape_diversity.where(test_1, average_elevation)\n\nAgora, nós adicionamos wetland score, primeiro testando onde wetland score é maior que a diversidade da paisagem calculada anteriormente, e nos locais cujos valores de wetland score são maiores que a diversidade da paisagem, nós substituímos os valores.\n\n# testando onde wetland score é maior que a diversidade da paisagem\n# com variedade de landforms e amplitude de elevação\ntest_2 = wetland_score.gt(landscape_diversity)\n\n# Médias para cada teste\n\naverage_wetland_1 = landform_Z.multiply(2).add(elevation_range_Z).add(wetland_score).divide(4)\n\naverage_wetland_2 = landform_Z.multiply(2).add(wetland_score).divide(3)\n\n# Substitua o valor de diversidade da paisagem por wetland score\n# onde o segundo é maior que o primeiro\nlandscape_diversity = landscape_diversity.where(test_1.And(test_2), average_wetland_1)\n\nlandscape_diversity = landscape_diversity.where(test_1.Not().And(test_2), average_wetland_2)\n\nA inclusão da diversidade de solos é um pouco mais complexa. Nós testamos onde a diversidade de solo é maior a diversidade da paisagem já calculada e substituímos os valores por 4 médias ponderadas diferentes, cada uma representando os passos anteriores. A primeira média é para os locais onde a diversidade de solos é maior que wetland score, que é maior que amplitude de elevação. Na segunda média, os valores são para as regiões com maior diversidade de solos, mas onde wetland score é menor que a amplitude de elevação. A terceira média é para locais onde a amplitude de elevação não é maior que variedade de landforms, mas possui valores menores de wetland score, que também são menores que a diversidade de solos. A quarta média é para locais onde somente a diversidade de solos é maior que a variedade de landforms.\n\n# teste onde diversidade de solo é maior que a diversidade da paisagem\ntest_3 = soil_diversity.gt(landscape_diversity)\n\n# Calcule as médias ponderadas\naverage_soil_1 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(5))\n\naverage_soil_2 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_3 = (landform_Z.multiply(2)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_4 = (landform_Z.multiply(2)\n                 .add(soil_diversity)\n                 .divide(3))\n\n# Substitua os valores de diversidade da paisagem pela diversidade de solo\n# os os valores de solo são maiores\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2).And(test_3), average_soil_1))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2.Not()).And(test_3), average_soil_2))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2).And(test_3), average_soil_3))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2.Not()).And(test_3), average_soil_4))\n\nFinalizamos exportando o mapa de diversidade da paisagem como asset no Google Earth Engine."
  },
  {
    "objectID": "7_resilience.html",
    "href": "7_resilience.html",
    "title": "Resiliência da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA resiliência da paisagem é classificada pela heterogeneidade da paisagem e conectividade local (Anderson et al. 2016). Modificamos a metodologia original de média das métricas pela classificação pelos quantis das duas variáveis. Classificamos as métricas por quantis e atribuímos classes para as combinações de quantis de heterogeneidade da paisagem e conectividade local de cada célula. Por exemplo, células com alta heterogeneidade local (quantil superior) e alta conectividade local (quantil superior) são áreas com alta resiliência. Por outro lado, locais com baixa conectividade local e heterogeneidade da paisagem possuem baixa resiliência. Nas classes intermediárias estão as células com alta heterogeneidade da paisagem e baixa conectividadel local, e as células com alta conectividade local e baixa heterogeneidade da paisagem."
  },
  {
    "objectID": "7_resilience.html#importando-pacotes-e-inicializando-geemap",
    "href": "7_resilience.html#importando-pacotes-e-inicializando-geemap",
    "title": "Resiliência da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA resiliência da paisagem é classificada pela heterogeneidade da paisagem e conectividade local (Anderson et al. 2016). Modificamos a metodologia original de média das métricas pela classificação pelos quantis das duas variáveis. Classificamos as métricas por quantis e atribuímos classes para as combinações de quantis de heterogeneidade da paisagem e conectividade local de cada célula. Por exemplo, células com alta heterogeneidade local (quantil superior) e alta conectividade local (quantil superior) são áreas com alta resiliência. Por outro lado, locais com baixa conectividade local e heterogeneidade da paisagem possuem baixa resiliência. Nas classes intermediárias estão as células com alta heterogeneidade da paisagem e baixa conectividadel local, e as células com alta conectividade local e baixa heterogeneidade da paisagem."
  },
  {
    "objectID": "7_resilience.html#base-de-dados",
    "href": "7_resilience.html#base-de-dados",
    "title": "Resiliência da paisagem",
    "section": "Base de dados",
    "text": "Base de dados\nOs dados utilizados para calcular a resiliência da paisagem são os mapa de heterogeneidade da paisagem e a conectividade local criados anteriormente."
  },
  {
    "objectID": "7_resilience.html#códigos-para-a-criação-da-resiliência-da-paisagem",
    "href": "7_resilience.html#códigos-para-a-criação-da-resiliência-da-paisagem",
    "title": "Resiliência da paisagem",
    "section": "Códigos para a criação da resiliência da paisagem",
    "text": "Códigos para a criação da resiliência da paisagem\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/7_resilience.ipynb.\nPrimeiro, importamos o polígono de biomas do Brasil para extraímos as coordenadas geográficas mínimas e máximas. Extraímos também a escala do modelo digital de elevação que usamos nas análises anteriores.\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()\n\nImportamos os mapas de heterogeneidade da paisagem e conectividade local.\n\n# modifique os endereços para os do seu projeto\n\nlocal_connectedness = ee.Image(\"projects/ee-lucasljardim9/assets/local_connectedness\")\n\nlandscape_heterogeneity = ee.Image(\"projects/ee-lucasljardim9/assets/landscape_heterogeneity\")\n\nCalculamos os quantis de 25, 50, 75% da heterogeneidade da paisagem e conectividade local.\n\n# Heterogeneidade da paisagem\nquartiles_Div = landscape_heterogeneity.reduceRegion(**{\n    'reducer': ee.Reducer.percentile([25, 50, 75]), \n    'scale': escala,\n    'maxPixels':1e13,\n    'bestEffort': False\n  })\n\n# Extraímos os valores do quantis\ndiv_25 = quartiles_Div.getNumber('z_p25')\ndiv_50 = quartiles_Div.getNumber('z_p50')\ndiv_75 = quartiles_Div.getNumber('z_p75')\n\n# Conectividade local\nquartiles_Con = local_connectedness.reduceRegion(**{\n    'reducer': ee.Reducer.percentile([25, 50, 75]), \n    'scale': escala,\n    'maxPixels':1e13,\n    'bestEffort': False\n  })\n\n# Extraímos os valores do quantis\ncon_25 = quartiles_Con.getNumber('b1_p25')\ncon_50 = quartiles_Con.getNumber('b1_p50')\ncon_75 = quartiles_Con.getNumber('b1_p75')\n\nClassificamos a heterogeneidade da paisagem e conectividade local pelos quantis.\n\nclass_div = (landscape_heterogeneity\n             .where(landscape_heterogeneity.lt(div_25), 1)  \n             .where(landscape_heterogeneity.gte(div_25).And(landscape_heterogeneity.lt(div_50)), 2)\n             .where(landscape_heterogeneity.gte(div_50).And(landscape_heterogeneity.lt(div_75)), 3)\n             .where(landscape_heterogeneity.gte(div_75).And(landscape_heterogeneity), 4))\n\n\nclass_con = (local_connectedness\n             .where(local_connectedness.lt(con_25),10)\n             .where(local_connectedness.gte(con_25).And(local_connectedness.lt(con_50)), 20)\n             .where(local_connectedness.gte(con_50).And(local_connectedness.lt(con_75)),30)\n             .where(local_connectedness.gte(con_75).And(local_connectedness), 40))\n\nSomamos os mapas de heterogeneidade da paisagem e conectividade local classificados para atribuirmos as classes de resiliência.\n\nresilience = class_div.add(class_con)\n\nExportamos o mapa de resiliência como um asset no Google Earth Engine.\n\n# Exporte o raster de resiliência\n# modifique o assetId para o do seu projeto\n\nassetId = \"projects/ee-lucasljardim9/assets/resilience\"\n\ngeemap.ee_export_image_to_asset(\n    resilience, \n    description='resilience', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,\n    maxPixels=1e13\n)"
  },
  {
    "objectID": "1_landforms.html#classificando-as-formas-do-relevo",
    "href": "1_landforms.html#classificando-as-formas-do-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Classificando as formas do relevo",
    "text": "Classificando as formas do relevo\n\nFormas do relevo\nUtilizamos a metodologia proposta por Anderson et al. (2016) para definir as formas de relevo (do inglês, landforms). As formas de relevo geradas foram:\n\n3 - Cool Steep Slope\n4 - Warms Steep Slope\n5 - Cliff\n11 - Summit/Ridgetop\n13 - Slope Crest\n21 - Flat Hilltop\n22 - Gentle Slope Hilltop\n23 - Cool Sideslope\n24 - Warm Sideslope\n30 - Dry Flats\n32 - Valley/Toeslope\n39 - Moist Flats\n43 - Cool Footslope\n44 - Warm Sideslope\n\n\n\nVariáveis classificadoras das formas de relevo\nAs variáveis utilizadas para calcular as formas de relevo foram: declividade (slope), exposição (aspect), Índice de Posição Topográfica (TPI, do inglês Topographic Position Index) e índice de umidade (moisture index). As formas de relevo são classificadas principalmente por declividade e TPI (Figura 1). A exposição classifica as faces quentes ou frias do relevo e o índice de umidade classifica as áreas planas em secas ou úmidas.\n\nFigura 1. Classificação das formas de relevo pela declividade, exposição, índice de posição topográfica e índice de umidade. Adaptação de @anderson_resilient_2016.\nAs variáveis foram discretizadas em classes e combinadas para comporem os tipos de formas de relevo. Os limiares utilizados para a discretização (Tabela 1) foram definidos por ajustes visuais que melhor representavam as formas de relevo.\n           Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n\n\n\nVariável\nClasse\nLimiar inferior\nLimiar superior\n\n\n\n\nDeclividade\n1\n-1\n2\n\n\nDeclividade\n2\n2\n6\n\n\nDeclividade\n3\n6\n24\n\n\nDeclividade\n4\n24\n35\n\n\nDeclividade\n5\n35\n90\n\n\nTPI\n1\n-Inf\n-15\n\n\nTPI\n2\n-15\n-1\n\n\nTPI\n3\n-1\n30\n\n\nTPI\n4\n30\n975\n\n\nExposição\n2\n0\n90\n\n\nExposição\n1\n90\n270\n\n\nExposição\n2\n270\n360\n\n\nÍndice de umidade\n0\n-Inf\n30000\n\n\nÍndice de umidade\n1\n3000\nInf\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de índice de umidade, 2 de exposição, 3 de TPI e 1 de declividade. Posteriormente, os valores finais foram convertidos em tipos de formas de relevo, seguindo a classificação indicada na Tabela 2.\nTabela 2. Tabela 2. Critério de conversão dos códigos da combinação de classes em tipos de formas de relevo.\n\n\n\nCódigo\nFormas de relevo\n\n\n\n\n10\n11\n\n\n11\n11\n\n\n12\n11\n\n\n13\n13\n\n\n14\n11\n\n\n15\n5\n\n\n20\n21\n\n\n21\n21\n\n\n22\n22\n\n\n23\n24\n\n\n24\n24\n\n\n25\n5\n\n\n31\n30\n\n\n32\n32\n\n\n33\n24\n\n\n34\n24\n\n\n35\n5\n\n\n40\n32\n\n\n41\n32\n\n\n42\n32\n\n\n43\n43\n\n\n44\n3\n\n\n45\n5\n\n\n51\n51\n\n\n111\n11\n\n\n112\n11\n\n\n113\n13\n\n\n114\n3\n\n\n115\n5\n\n\n121\n21\n\n\n122\n22\n\n\n123\n23\n\n\n124\n3\n\n\n125\n5\n\n\n131\n30\n\n\n132\n32\n\n\n133\n23\n\n\n134\n3\n\n\n135\n5\n\n\n141\n32\n\n\n142\n32\n\n\n143\n43\n\n\n144\n3\n\n\n145\n5\n\n\n151\n51\n\n\n211\n11\n\n\n212\n11\n\n\n213\n13\n\n\n214\n4\n\n\n215\n5\n\n\n221\n21\n\n\n222\n22\n\n\n223\n24\n\n\n224\n4\n\n\n225\n5\n\n\n231\n30\n\n\n232\n32\n\n\n233\n24\n\n\n234\n4\n\n\n235\n5\n\n\n241\n32\n\n\n242\n32\n\n\n243\n44\n\n\n244\n4\n\n\n245\n5\n\n\n251\n51\n\n\n1000\n39"
  },
  {
    "objectID": "1_landforms.html#cálculo-da-variedade-de-formas-de-relevo",
    "href": "1_landforms.html#cálculo-da-variedade-de-formas-de-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Cálculo da variedade de formas de relevo",
    "text": "Cálculo da variedade de formas de relevo\n\nBases de dados\nClassificamos as formas de relevo utilizando o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), o acúmulo de fluxo do Merit-Hydro (Yamazaki et al. 2019) e a camada de uso do solo do MapBiomas (MapBiomas Project 2020). O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono, T. et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\nIncluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto."
  },
  {
    "objectID": "1_landforms.html#códigos-para-a-criação-da-variedade-de-formas-do-relevo",
    "href": "1_landforms.html#códigos-para-a-criação-da-variedade-de-formas-do-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Códigos para a criação da variedade de formas do relevo",
    "text": "Códigos para a criação da variedade de formas do relevo\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para replicação da análise pode ser baixado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb.\n\nDeclividade (slope)\nNós criamos a superfície de declividade a partir do Merit-DEM.\n\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando a declividade\n\nslope = ee.Terrain.slope(DEM)\n\n\n\nExposição (aspect)\nNós calculamos a exposição do relevo utilizando o mesmo DEM.\n\naspect = ee.Terrain.aspect(DEM)\n\n\n\nÍndice de Posição Topográfica (TPI)\nNós calculamos o Índice de Posição Topográfica (TPI)(Weiss 2001) para cada célula do raster dentro de um kernel circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\\(TPI = \\frac{\\sum_{i}^{n}(vizinhança_i - focal)}{n}\\)\na vizinhança i representa cada uma das n células dentro do kernel da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional (Theobald et al. 2015). Os tamanhos das janelas foram definidos visualmente para que melhor representassem as formas do relevo, principalmente os Summits, Valleys, Toeslopes e Hilltops (flat e gentle). Os tamanhos das janelas também tinham que capturar os platôs das Chapadas como Summits.\n\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n\n\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n\n\n\nÍndice de umidade (Moisture index)\nNós calculamos o índice de umidade (Anderson et al. 2016) baseado no acúmulo de fluxo presente no Merit-Hydro (Yamazaki et al. 2019), na camada upg, que é calculado sobre o Merit-DEM. O índice de umidade é calculado da seguinte forma:\n\\(moisture.index = \\frac{\\log(fluxo + 1)}{(declividade + 1)} \\times 1000\\)\nonde fluxo é o acúmulo de fluxo e declividade é a calculada anteriormente. O índice de umidade é a média do índice dentro de um kernel circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d’água.\n\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o índice de umidade\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)"
  },
  {
    "objectID": "1_landforms.html#convertendo-variáveis-em-classes",
    "href": "1_landforms.html#convertendo-variáveis-em-classes",
    "title": "Variedade de formas do relevo",
    "section": "Convertendo variáveis em classes",
    "text": "Convertendo variáveis em classes\n\nDeclividade (slope)\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo (Anderson et al. 2016). As classes de declividade foram criadas com o seguinte código:\n\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n\n\n\nExposição (aspect)\nA exposição foi escolhido para definir as faces quentes e frias no hemisfério sul.\n\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2) # face quente\n    .where(aspect.gt(90).And(aspect.lte(270)), 1) # face fria\n    .where(aspect.gt(270).And(aspect.lte(360)), 2) # face quente\n)\n\n\n\nÍndice de Posição do Relevo (TPI)\nAs classes de TPI foram definidas para representarem bem os Summits, Valleys, Toeslopes e Hilltops, que foram as formas do relevo mais difíceis de ajustar os parâmetros.\n\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n\n\n\nÍndice de Umidade (moisture index)\nO limiar do índice de umidade para classificar as áreas como umidas ou secas foi definido visualmente para capturar a distribuição dos cursos d’água sem criar áreas planas secas com excesso de ramificações dendríticas. Os grandes rios, represas e lagoas (ex. Rio Amazonas) não foram bem representados pelo índice de umidade, pois ele classificava somente as partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d’água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a classe de águas presente no MapBiomas.\n\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n\n\n\nCombinando as classes\nCombinamos as classes para gerar um código representativo de cada variável. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1.\n\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n\n\n\nClassificando as formas do relevo\nClassificamos as formas do relevo pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as formas do relevo. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (Summit). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de formas de relevo como Sideslopes de Valleys e Toeslopes.\n\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n\n\n\nExportando mapas para assets\n\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n\n\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=regiao_box, scale=escala,maxPixels=1e13\n)\n\n\n\nExemplo de formas de relevo\nAbaixo está uma representação das formas de relevo na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n%%capture --no-display\n#| echo: false\n\n# Delimitando a região\nbb = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=bb, file_per_band=False\n)\n\n\n# Paleta de cores das formas de relevo\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n\n      Figura 2. Formas de relevo classificadas na região de Alto Paraíso de Goiás-GO, Brasil."
  },
  {
    "objectID": "1_landforms.html#calculando-a-variedade-de-formas-de-relevo",
    "href": "1_landforms.html#calculando-a-variedade-de-formas-de-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Calculando a variedade de formas de relevo",
    "text": "Calculando a variedade de formas de relevo\nA variedade de formas do relevo foi calculada como a soma dos tipos de formas dentro de um kernel circular de uma célula focal. O tamanho do raio do kernel foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele no qual o raio subsequente não adicionou variedade. Dessa forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de formas do relevo. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de formas do relevo para a mesma região de Alto Paraíso de Goiás-GO.\n\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n\n\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=bb, file_per_band=False\n)\n\n\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n\n        Figura 3. Variedade de formas de relevo para região de Alto Paraíso de Goiás-GO, Brasil.\n\n# modifique o assetId para o endereço do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,maxPixels=1e13\n)"
  },
  {
    "objectID": "2_elevation_range.html#cálculo-da-amplitude-altitudinal",
    "href": "2_elevation_range.html#cálculo-da-amplitude-altitudinal",
    "title": "Amplitude altitudinal",
    "section": "Cálculo da amplitude altitudinal",
    "text": "Cálculo da amplitude altitudinal\nA amplitude altitudinal foi calculada como a diferença entre a altitude máxima e mínima dentro da vizinhaça da célula focal. Como essa métrica é correlacionada com a variedade de formas de relevo, nós calculamos o resíduos de uma regressão (Ordinary Least Squares) entre as duas váriaveis (Anderson et al. 2016). Assim, a amplitude altitudinal residual é independente da variedade de formas de relevo. Isso permite a identificação de locais que tenham maior variabilidade microclimática que aquela proporcionada pela variedade de formas de relevo, quando calcularmos o índice de diversidade da paisagem."
  },
  {
    "objectID": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-altitudinal-residual",
    "href": "2_elevation_range.html#códigos-para-o-cálculo-da-amplitude-altitudinal-residual",
    "title": "Amplitude altitudinal",
    "section": "Códigos para o cálculo da amplitude altitudinal residual",
    "text": "Códigos para o cálculo da amplitude altitudinal residual\nPrimeiro, importamos um vetor dos biomas do Brasil para extrairmos as coordenadas mínimas e máximas do Brasil.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\nImportamos os rasters do modelo digital de elevação e da variedade de formas de relevo e definimos a resolução da análise como aquela do modelo digital de elevação.\n\n# Importando o modelo digital de elevação\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# Importando a variedade de landforms calculada anteriormente\n# modifique o endereço para o do seu projeto\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\n#Escala dos rasters ~92 metros\nescala = DEM.projection().nominalScale()\n\nExtraímos do raster as células dentro da vizinhança (kernel circular com 5 células de raio, ~450 metros) da célula focal e salvamos como bandas de uma imagem. Assim, cada banda é um stack das células da vizinhança da célula focal, a primeira banda possui todas as primeiras células de cada célula focal, a segunda banda todas as segunda células, e assim por diante.\n\n# Tamanho do raio do kernel para o calculo da amplitude altitudinal\nradius_pixels = 5\n\n# Criando rasters da vizinhança de cada célula como bandas da imagem\nneighbor = DEM.neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels)))\n\nO raster neighbor criado acima possui as células da vizinhança como bandas. Assim, as primeiras células de cada banda são as células da vizinhança da primeira célula focal, organizadas como colunas (bandas). Ao calcularmos os valores máximos e mínimos para cada coluna de neighbor, estamos calculando os valores máximos e mínimos da vizinhança de cada célula focal.\n\n# Calcule o máximo da vizinhança\nelevation_max = neighbor.reduce(ee.Reducer.max())\n\n# Calcule o mínimo da vizinhança\nelevation_min = neighbor.reduce(ee.Reducer.min())\n\nSubtraindo os valores máximos e mínimos de cada célula focal e calculando o seu valor absoluto, temos a amplitude altitudinal para cada célula focal. Nós salvamos a amplitude altitudinal e variedade de formas de relevo como um raster com duas bandas, sendo a primeira banda a variável preditora da regressão e a segunda banda a variável resposta.\n\n# Calcule a amplitude da vizinhança\nelevation_range = elevation_max.subtract(elevation_min).abs()\n\n# Crie uma imagem com as bandas de varidedade de formas de relevo e amplitude altitudinal \n# A primeira imagem é o x da regressão e a segunda é o y\n\nelevation = (ee.Image.cat(landform_variety, elevation_range)\n            .rename(['landform_variety', 'elevation_range']))\n\nDessa forma, aplicamos a regressão entre as variáveis.\n\n# Rode uma regressão linear (OLS) entre varidade formas de relevo e amplitude altitudinal\nregression = elevation.reduceRegion(**{\n     'reducer': ee.Reducer.linearFit(),\n     'geometry': regiao_box,\n     'maxPixels': 1e13,\n     'scale': escala\n    })\n\nApós a regressão, multiplicamos a variável preditora pelo coeficiente de regressão (slope) e adicionamos o valor do intercepto para predizermos os valores de amplitude altitudinal esperados pela regressão. Em seguida, subtraímos os valores de amplitude altitudinal pelos valores preditos pela regressão para calcularmos os resíduos do modelo.\n\n# Calcule o valor predito, pela regressão, de amplitude altitudinal, sem intercepto \npred = elevation.select('landform_variety').multiply(ee.Number(regression.get('scale')))\n\n# Adicione o intercepto na predição\npredict = pred.add(ee.Number(regression.get('offset')))\n\n# Calcule o residuo da regressão\nresiduals = elevation.select('elevation_range').subtract(predict).rename(['residuals'])\n\nPor fim, exportamos o raster de amplitude altitudinal residual como um asset do Google Earth Engine.\n\n# Exporte a amplitude altitudinal residual como asset\n# modifique o assetId para o do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/elevation_range_residual\"\n\ngeemap.ee_export_image_to_asset(\n    residuals, \n    description='elevation_range_residual', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  },
  {
    "objectID": "4_soil_diversity.html#banco-de-dados",
    "href": "4_soil_diversity.html#banco-de-dados",
    "title": "Riqueza de solos",
    "section": "Banco de Dados",
    "text": "Banco de Dados\nUtilizamos a base de dados de pedologia do Instituto Brasileiro de Geografia e Estatística (IBGE) (https://geoftp.ibge.gov.br/informacoes_ambientais/pedologia/vetores/escala_250_mil/versao_2023/pedo_area.zip) para o cálculo da riqueza de solos. Utilizamos o arquivo pedo_area.shp. Calculamos a quantidade de solos componentes de cada polígono e rasterizados na escala do modelo digital de elevação utilizado nas etapas anteriores (~ 92 metros)."
  },
  {
    "objectID": "4_soil_diversity.html#códigos-para-a-criação-da-riqueza-de-solos",
    "href": "4_soil_diversity.html#códigos-para-a-criação-da-riqueza-de-solos",
    "title": "Riqueza de solos",
    "section": "Códigos para a criação da riqueza de solos",
    "text": "Códigos para a criação da riqueza de solos\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017) , devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020), em Python (Python Software Foundation 2023), como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/4_soil_diversity.ipynb.\nO primeiro passo é criar uma função que conta os tipos de solos componentes de cada polígono. Concatenamos as colunas componente, component1, component2 e component3. Depois, separamos a string pelos sinais de “+”, que indicam as separações das descrições de cada tipo de solo. Em seguida, contamos quantos tipo de solos existem em cada polígono como o comprimento da lista de tipos de solos. Adicionamos uma coluna chamada soil_richness com a riqueza de solos em cada polígono.\n\ndef fun(feature):\n    number = (ee.String(feature.get(\"componente\"))\n              .cat(ee.String(feature.get(\"component1\")))\n              .cat(ee.String(feature.get(\"component2\")))\n              .cat(ee.String(feature.get(\"component3\")))\n              .split(\"\\+\")\n              .length())\n\n    return feature.set(\"soil_richness\", number)\n\nEm seguida, importamos os dados de solo, definimos a região para exportar o dado e a escala da análise.\n\n# Importando os polígonos de solo\nsolo = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/pedo_area\")\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\nAplicamos a função criada anteriormente aos polígonos de solo.\n\nsolo = solo.map(fun)\n\nRasterizamos a riqueza de solos na mesma escala das análises anteriores.\n\nsoil_diversity = solo.reduceToImage(**{'properties':[\"soil_richness\"],\n                     'reducer':ee.Reducer.max()}) \\\n                     .reproject(**{'crs':\"EPSG:4326\",\n                                  'scale':escala})\n\nPor fim, exportamos o raster como um asset no Google Earth Engine.\n\n# Exporte o raster de riqueza de solo \n#modifique o assetId para do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/soil_diversity\"\n\ngeemap.ee_export_image_to_asset(\n    soil_diversity, description='soil_diversity', assetId=assetId, region=regiao_box, scale=escala, maxPixels=1e13\n)"
  },
  {
    "objectID": "5_Z_scores.html#códigos-para-o-cálculo-dos-valores-de-z",
    "href": "5_Z_scores.html#códigos-para-o-cálculo-dos-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Códigos para o cálculo dos valores de Z",
    "text": "Códigos para o cálculo dos valores de Z\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para reprodução da análise pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/5_Z_scores.ipynb.\nPrimeiro, criamos uma função para calcular o valor de Z dentro de cada janela móvel (code) para cada variável (image). A função calcula a média e desvio padrão para a vizinhança de cada célula, utilizando uma janela móvel circular. Depois, os valores e média e desvio padrão convertidos para valores de Z pela subtração da variável pela média e divida pelo desvio padrão.\n\ndef calculate_Z_scores(image, windows):\n\n  # Calculando a média\n  mean = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.mean(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Calculando o desvio padrão\n  sd = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.stdDev(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Renomeie os rasters\n  meanValue = mean.rename('mean')\n  sdValue = sd.rename('sd')\n\n  # Calculando os valores de Z\n  z = image.subtract(meanValue).divide(sdValue).rename('z')\n\n  return z\n\nO próximo passo é importar as variáveis de interesse para o cálculo de Z.\n\n# Importando as variáveis\n\n# modificar os endereços para os dos projetos\n\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/elevation_range_residual\")\n\nsoil_diversity = ee.Image('projects/ee-lucasljardim9/assets/soil_diversity')\n\n\n# Importando os dados de wetlands para o wetland score\n\nwetlands_count = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_count\")\n\nwetlands_density = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density\")\n\nwetlands_density_1000 = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density_1000\")\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()"
  },
  {
    "objectID": "5_Z_scores.html#calculando-os-valores-de-z",
    "href": "5_Z_scores.html#calculando-os-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Calculando os valores de Z",
    "text": "Calculando os valores de Z\nNós aplicamos a função calculate_Z_scores para cada variável e guardamos o valores de Z calculados.\n\n# Definindo a janela para o cálculo do do Z \nwindows = 200\n\n# Calculando os valores de Z para cada variável\nZ_landform_variety = calculate_Z_scores(landform_variety, windows)\n\nZ_elevation_range = calculate_Z_scores(elevation_range, windows)\n\nZ_soil_diversity = calculate_Z_scores(soil_diversity, windows)\n\nZ_wetlands_count = calculate_Z_scores(wetlands_count, windows)\n\nZ_wetlands_density = calculate_Z_scores(wetlands_density, windows)\n\nZ_wetlands_density_1000 = calculate_Z_scores(wetlands_density_1000, windows)"
  },
  {
    "objectID": "5_Z_scores.html#calculando-índice-de-áreas-úmidas",
    "href": "5_Z_scores.html#calculando-índice-de-áreas-úmidas",
    "title": "Valor de Z das variáveis",
    "section": "Calculando índice de áreas úmidas",
    "text": "Calculando índice de áreas úmidas\nAqui, nós calculamos o índice de áreas úmidas, aplicando a fórmula descrita anteriormente.\n\n# Calculando a densidade de areas úmidas como a média do local e regional\nwetlands_density = (Z_wetlands_density\n                    .multiply(2)\n                    .add(Z_wetlands_density_1000)\n                    .divide(3))\n\n# Testando se o Z da quantidade de áreas úmidas é maior que a densidade média\n\nwet_test = wetlands_density.lt(Z_wetlands_count)\n\n# Média de densidade local, regional e quantidade de áreas úmidas\nwet_average = (wetlands_density\n              .multiply(3)\n              .add(Z_wetlands_count)\n              .divide(4))\n\n# Substituindo os locais com densidade menor que a quantidade pelos valores de quantidade             \nZ_wetlands_score = Z_wetlands_density.where(wet_test, wet_average)"
  },
  {
    "objectID": "5_Z_scores.html#exportando-os-valores-de-z",
    "href": "5_Z_scores.html#exportando-os-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Exportando os valores de Z",
    "text": "Exportando os valores de Z\nPor último, exportamos todas as imagens de Z como asset no Google Earth Engine.\n\n# Criando os links dos assets\n# modifique os assetIds para os dos seus projetos\n\nlandform_assetId = \"projects/ee-lucasljardim9/assets/Z_landform_variety\"\n\nelevation_assetId = \"projects/ee-lucasljardim9/assets/Z_elevation_range\"\n\nwetland_assetId = \"projects/ee-lucasljardim9/assets/Z_wetlands_score\"\n\nsoil_assetId = \"projects/ee-lucasljardim9/assets/Z_soil_diversity\"\n\n# Exportando as imagens\ngeemap.ee_export_image_to_asset(\n    Z_landform_variety, \n    description='Z_landform_variety', \n    assetId=landform_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_elevation_range, \n    description='Z_elevation_range', \n    assetId=elevation_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_wetlands_score, \n    description='Z_wetlands_score', \n    assetId=wetland_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_soil_diversity, \n    description='Z_soil_diversity', \n    assetId=soil_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)"
  },
  {
    "objectID": "5_Z_scores.html#cálculo-do-valor-de-z",
    "href": "5_Z_scores.html#cálculo-do-valor-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Cálculo do valor de Z",
    "text": "Cálculo do valor de Z\nAntes de calcularmos a diversidade da paisagem e a resiliência, nós transformamos as variáveis (variedade de formas de relevo, amplitude altitudinal, densidade, quantidade de áreas úmidas e riqueza de solo) em valores de Z (Anderson et al. 2016). O cálculo de Z é realizado dentro das janelas móveis. Um fato importante é a posterior tranformação dos valores de densidade e quantidade de áreas úmidas em índice de áreas úmidas.\nOs valores de Z de cada variável, em cada célula (i), é o desvio do valor da célula da média da janela móvel (u), divido pelo seu desvio padrão:\n\\[Z-score_{iu} = \\frac{i - media_{u}}{desviopadrao_{u}}\\]"
  },
  {
    "objectID": "5_Z_scores.html#índice-de-áreas-úmidas",
    "href": "5_Z_scores.html#índice-de-áreas-úmidas",
    "title": "Valor de Z das variáveis",
    "section": "Índice de áreas úmidas",
    "text": "Índice de áreas úmidas\nO índice de áreas úmidas é a média ponderada das densidades locais e regionais de áreas úmidas. Em locais onde o valor de Z da densidade média é menor que o Z da quantidade de áreas úmidas, o índice de áreas úmidas assume o segundo valor Z (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]"
  },
  {
    "objectID": "6_landscape_heterogeneity.html",
    "href": "6_landscape_heterogeneity.html",
    "title": "Heterogeneidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA heterogeneidade da paisagem é uma métrica composta pelos valores de Z da variedade de formas de relevo, amplitude altitudinal, índice de áreas úmidas e riqueza de solos (Anderson et al. 2016). O cálculo da heterogeneidade da paisagem consiste de uma série de etapas:\n\n\nA heterogeneidade da paisagem assume os valores de variedade de formas de relevo;\n\n\nLocais onde a amplitude altitudinal é maior que variedade de formas de relevo, a heterogeneidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de de formas de relevo;\n\n\nLocais onde o índice de áreas úmidas é maior que a heterogeneidade da paisagem calculada anteriormente, os valores são substituídos pela média ponderada das variáveis, atribuindo pelo duplo para a variedade de formas de relevo;\n\n\nLocalidades onde a riqueza de solos é maior que a heterogeneidade da paisagem das etapas anteriores, os valores são substituídos pela média ponderada das variáveis naquela localidade, atribuindo peso duplo para a variedade de formas de relevo."
  },
  {
    "objectID": "6_landscape_heterogeneity.html#importando-pacotes-e-inicializando-geemap",
    "href": "6_landscape_heterogeneity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Heterogeneidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA heterogeneidade da paisagem é uma métrica composta pelos valores de Z da variedade de formas de relevo, amplitude altitudinal, índice de áreas úmidas e riqueza de solos (Anderson et al. 2016). O cálculo da heterogeneidade da paisagem consiste de uma série de etapas:\n\n\nA heterogeneidade da paisagem assume os valores de variedade de formas de relevo;\n\n\nLocais onde a amplitude altitudinal é maior que variedade de formas de relevo, a heterogeneidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de de formas de relevo;\n\n\nLocais onde o índice de áreas úmidas é maior que a heterogeneidade da paisagem calculada anteriormente, os valores são substituídos pela média ponderada das variáveis, atribuindo pelo duplo para a variedade de formas de relevo;\n\n\nLocalidades onde a riqueza de solos é maior que a heterogeneidade da paisagem das etapas anteriores, os valores são substituídos pela média ponderada das variáveis naquela localidade, atribuindo peso duplo para a variedade de formas de relevo."
  },
  {
    "objectID": "6_landscape_heterogeneity.html#base-de-dados",
    "href": "6_landscape_heterogeneity.html#base-de-dados",
    "title": "Heterogeneidade da paisagem",
    "section": "Base de dados",
    "text": "Base de dados\nOs dados para a heterogeneidade da paisagem foram criados na etapa de cálculo dos valores de Z."
  },
  {
    "objectID": "6_landscape_heterogeneity.html#códigos-para-a-criação-da-heterogeneidade-da-paisagem",
    "href": "6_landscape_heterogeneity.html#códigos-para-a-criação-da-heterogeneidade-da-paisagem",
    "title": "Heterogeneidade da paisagem",
    "section": "Códigos para a criação da heterogeneidade da paisagem",
    "text": "Códigos para a criação da heterogeneidade da paisagem\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução da análise pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/6_landscape_diversity.ipynb.\nImportamos os dados de bioma para delimitar a região de análise e definimos a escala espacial da análise como nas etapas anteriores.\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()\n\nImportamos os mapas.\n\n# Importando e cortando as imagens para o Brasil\n# modifique os endereços para os do seu projeto\nlandform_Z = ee.Image('projects/ee-lucasljardim9/assets/Z_landform_variety')\n              \n\nelevation_range_Z = ee.Image('projects/ee-lucasljardim9/assets/Z_elevation_range')\n                    \n\nwetland_score = ee.Image('projects/ee-lucasljardim9/assets/Z_wetlands_score')\n                 \n\nsoil_diversity =  ee.Image('projects/ee-lucasljardim9/assets/Z_soil_diversity')\n\nO cálculo da heterogeneidade da paisagem inicia atribuindo à heterogeneidade da paisagem os valores de variedade de formas de relevo. Em um segundo momento, avaliamos os locais onde a amplitude altitudinal é maior que a variedade de formas de relevo e substituímos os valores.\n\nlandscape_diversity = landform_Z\n\n# Testando se o Z da amplitude altitudinal é maior que o Z da variedade de formas de relevo\ntest_1 = elevation_range_Z.gt(landscape_diversity)\n\n# Média ponderada entre variedade de formas de relevo e amplitude altitudinal\naverage_elevation = landform_Z.multiply(2).add(elevation_range_Z).divide(3)\n\n# Substituindo os valores de variedade de formas de relevo por amplitude altitudinal \n# onde o segundo valor é maior que o primeiro\nlandscape_diversity = landscape_diversity.where(test_1, average_elevation)\n\nEm seguida, adicionamos o índice de áreas úmidas, primeiro avaliando onde esse índice é maior que a heterogeneidade da paisagem calculada anteriormente. Nos locais onde os valores do índice de áreas úmidas são maiores que a heterogeneidade da paisagem, os valores são substituídos.\n\n# testando onde índice de áreas úmidas é maior que a heterogeneidade da paisagem\n\ntest_2 = wetland_score.gt(landscape_diversity)\n\n# Médias para cada teste\n\n# Locais que a amplitude altitudinal foi maior que variedade de formas de relevo\naverage_wetland_1 = landform_Z.multiply(2).add(elevation_range_Z).add(wetland_score).divide(4)\n\n# Locais onde a amplitude altitudinal não foi maior que variedade de formas de relevo\naverage_wetland_2 = landform_Z.multiply(2).add(wetland_score).divide(3)\n\n# Substitua o valor de heterogeneidade da paisagem pelo índice de áreas úmidas\n\nlandscape_diversity = landscape_diversity.where(test_1.And(test_2), average_wetland_1)\n\nlandscape_diversity = landscape_diversity.where(test_1.Not().And(test_2), average_wetland_2)\n\nA inclusão da riqueza de solos é um pouco mais complexa. Testamos onde a riqueza de solos é maior a heterogeneidade da paisagem anterior e substituímos os valores por 4 médias ponderadas diferentes, cada uma representando os passos anteriores. A primeira média é para os locais onde a riqueza de solos é maior que o índice de áreas úmidas, que por sua vez é maior que amplitude altitudinal. Na segunda média, os valores são para as regiões com maior riqueza de solos, mas onde o índice de áreas úmidas é menor que a amplitude altitudinal. A terceira média é para os locais onde a amplitude altitudinal é maior que variedade de formas de relevo, mas o índice de áreas úmidas não adiciona informação. A quarta média é para locais onde somente a riqueza de solos é maior que a variedade de formas de relevo.\n\n# teste onde riqueza de solo é maior que a heterogeneidade da paisagem\ntest_3 = soil_diversity.gt(landscape_diversity)\n\n# Calcule as médias ponderadas\naverage_soil_1 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(5))\n\naverage_soil_2 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_3 = (landform_Z.multiply(2)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_4 = (landform_Z.multiply(2)\n                 .add(soil_diversity)\n                 .divide(3))\n\n# Substitua os valores de heterogeneidade da paisagem pela riqueza de solos\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2).And(test_3), average_soil_1))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2.Not()).And(test_3), average_soil_2))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2).And(test_3), average_soil_3))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2.Not()).And(test_3), average_soil_4))\n\nFinalizamos exportando o mapa de heterogeneidade da paisagem como asset no Google Earth Engine.\n\n# Exporte o raster de heterogeneidade da paisagem\n# modifique assetId para o do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landscape_heterogeneity\"\n\ngeemap.ee_export_image_to_asset(\n    landscape_diversity, \n    description='landscape_heterogeneity', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,\n    maxPixels=1e13\n)"
  },
  {
    "objectID": "0_instalacao.html",
    "href": "0_instalacao.html",
    "title": "Instalação e ambiente para as análises",
    "section": "",
    "text": "As análises deste tutorial foram rodadas no Google Earth Engine (GEE) utilizando como interface o pacote geemap em Python. O tutorial está escrito no JupyterNotebook. Dessa forma, para a reprodução das análises é necessário a criação de uma conta no GEE. Em seguida, instale o Python, se não estiver instalado. Com o Python instalado, instale o JupyterNotebook. Por fim, instale o pacote geemap.\nAlguns pacotes auxiliares também são usados para produzir e exportar figuras como os e matplotlib. Escreva na linha de comando os seguintes códigos para instalar:\npip install os\n\npip install matplotlib\n\npip install pyxarray\n\npip install rioxarray"
  },
  {
    "objectID": "0_instalacao.html#bases-importadas",
    "href": "0_instalacao.html#bases-importadas",
    "title": "Instalação e ambiente para as análises",
    "section": "Bases importadas",
    "text": "Bases importadas\n\nArquivo vetorial dos biomas do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Biome.\n\nArquivo matricial com a classificação de áreas úmidas global produzido pelo Sustainable Wetlands Adaptation and Mitigation Program ( SWAMP ), Center for International Forestry Research (CIFOR) e United States Forest Service.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Cifor_wetlands.\n\nArquivo vetorial de pedologia do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/pedo_area.\n\nArquivo matricial da conectividade local produzido neste projeto utilizando o Omniscape.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness."
  },
  {
    "objectID": "1_landforms.html#conferir-a-criação-do-asset",
    "href": "1_landforms.html#conferir-a-criação-do-asset",
    "title": "Variedade de formas do relevo",
    "section": "Conferir a criação do asset",
    "text": "Conferir a criação do asset\nO asset pode demorar algumas horas para ser criado. Para conferir se o asset foi criado, rode a linha de comando abaixo. O código busca o nome do asset na nuvem do GEE. Se não funcionar, confira aqui como instalar as funções para uso da linha de comando.\n\nos.system(f\"earthengine ls projects/ee-lucasljardim9/assets| grep 'assets/landform_variety'\")\n\nOutra possibilidade é acessar a página do editor de código do GEE e na parte direita da tela, em Tasks, confira se o processo de criação finalizou com sucesso, colorido em azul. Vermelho indica que houve algum erro durante o processo.\n\nTambém é possível ver os assets na aba Assets, na parte esquerda da tela.\n\nVeja o dado criado com:\n\n# Paleta de cores\nsld_intervals =(\n'&lt;RasterSymbolizer&gt;' + \\\n  '&lt;ColorMap type=\"intervals\" extended=\"False\"&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffc408\" quantity=\"3\" label=\"Cool Steep Slope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffa101\" quantity=\"4\" label=\"Warm Steep Slope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ef595a\" quantity=\"5\" label=\"Cliff\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffbdbe\" quantity=\"11\" label=\"Summit/Ridgetop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#6e4100\" quantity=\"13\" label=\"Slope Crest\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#af7b53\" quantity=\"21\" label=\"Flat Hilltop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#c8c284\" quantity=\"22\" label=\"Gentle Slope Hilltop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#c8f6ad\" quantity=\"23\" label=\"Cool Sideslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#83e763\" quantity=\"24\" label=\"Warm Sideslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffffbe\" quantity=\"30\" label=\"Dry Flats\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#a9a800\" quantity=\"32\" label=\"Valley/Toeslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#b671f2\" quantity=\"39\" label=\"Moist Flats\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#08a702\" quantity=\"43\" label=\"Cool Footslope/Cove\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#0a7000\" quantity=\"44\" label=\"Warm Footslope/Cove\"/&gt;' + \\\n  '&lt;/ColorMap&gt;' + \\\n'&lt;/RasterSymbolizer&gt;')\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe o asset\n\nvariedade = ee.Image(\"projects/ee-lucasljardim9/assets/landform_types\")\n\n# Plote o mapa\n\nMap.addLayer(variedade.sldStyle(sld_intervals)) \n\n\nMap"
  },
  {
    "objectID": "0_instalacao.html#base-importada-do-mapbiomas",
    "href": "0_instalacao.html#base-importada-do-mapbiomas",
    "title": "Instalação e ambiente para as análises",
    "section": "Base importada do MapBiomas",
    "text": "Base importada do MapBiomas\nhttps://code.earthengine.google.com/?asset=projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2."
  },
  {
    "objectID": "0_instalacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "href": "0_instalacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "title": "Instalação e ambiente para as análises",
    "section": "Bases disponibilizadas pelo catálogo do Google Earth Engine",
    "text": "Bases disponibilizadas pelo catálogo do Google Earth Engine\n\nModelo Digital de Elevação\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_DEM_v1_0_3\n\n\nAcúmulo de fluxo\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_Hydro_v1_0_1"
  },
  {
    "objectID": "0_instalacao.html#dados-produzidos-pelas-análises",
    "href": "0_instalacao.html#dados-produzidos-pelas-análises",
    "title": "Instalação e ambiente para as análises",
    "section": "Dados produzidos pelas análises",
    "text": "Dados produzidos pelas análises\n\nVariedade de formas de relevo\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landform_variety\n\n\nAmplitude altitudinal\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/elevation_range_residual\n\n\nQuantidade de áreas úmidas\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_count\n\n\nDensidade de áreas úmidas local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density\n\n\nDensidade de áreas úmidas regional\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density_1000\n\n\nRiqueza de solos\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/soil_diversity\n\n\nValores de Z das variáveis\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_landform_variety\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_elevation_range\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_wetlands_score\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_soil_diversity\n\n\nHeterogeneidade da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landscape_heterogeneity\n\n\nConectividade local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness\n\n\nResiliência da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/resilience"
  },
  {
    "objectID": "landforms.html",
    "href": "landforms.html",
    "title": "Variedade de formas do relevo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "landforms.html#importando-pacotes-e-inicializando-geemap",
    "href": "landforms.html#importando-pacotes-e-inicializando-geemap",
    "title": "Variedade de formas do relevo",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport matplotlib as mpl\nimport matplotlib.pylab as plt\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "landforms.html#classificando-as-formas-do-relevo",
    "href": "landforms.html#classificando-as-formas-do-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Classificando as formas do relevo",
    "text": "Classificando as formas do relevo\n\nFormas do relevo\nUtilizamos a metodologia proposta por Anderson et al. (2016) para definir as formas de relevo (do inglês, landforms). As formas de relevo geradas foram:\n\n3 - Cool Steep Slope\n4 - Warms Steep Slope\n5 - Cliff\n11 - Summit/Ridgetop\n13 - Slope Crest\n21 - Flat Hilltop\n22 - Gentle Slope Hilltop\n23 - Cool Sideslope\n24 - Warm Sideslope\n30 - Dry Flats\n32 - Valley/Toeslope\n39 - Moist Flats\n43 - Cool Footslope\n44 - Warm Sideslope\n\n\n\nVariáveis classificadoras das formas de relevo\nAs variáveis utilizadas para calcular as formas de relevo foram: declividade (slope), exposição (aspect), Índice de Posição Topográfica (TPI, do inglês Topographic Position Index) e índice de umidade (moisture index). As formas de relevo são classificadas principalmente por declividade e TPI (Figura 1). A exposição classifica as faces quentes ou frias do relevo e o índice de umidade classifica as áreas planas em secas ou úmidas.\n\nFigura 1. Classificação das formas de relevo pela declividade, exposição, índice de posição topográfica e índice de umidade. Adaptação de @anderson_resilient_2016.\nAs variáveis foram discretizadas em classes e combinadas para comporem os tipos de formas de relevo. Os limiares utilizados para a discretização (Tabela 1) foram definidos por ajustes visuais que melhor representavam as formas de relevo.\n           Tabela 1. Descrição dos limiares de classificação de cada variável em classes.\n\n\n\nVariável\nClasse\nLimiar inferior\nLimiar superior\n\n\n\n\nDeclividade\n1\n-1\n2\n\n\nDeclividade\n2\n2\n6\n\n\nDeclividade\n3\n6\n24\n\n\nDeclividade\n4\n24\n35\n\n\nDeclividade\n5\n35\n90\n\n\nTPI\n1\n-Inf\n-15\n\n\nTPI\n2\n-15\n-1\n\n\nTPI\n3\n-1\n30\n\n\nTPI\n4\n30\n975\n\n\nExposição\n2\n0\n90\n\n\nExposição\n1\n90\n270\n\n\nExposição\n2\n270\n360\n\n\nÍndice de umidade\n0\n-Inf\n30000\n\n\nÍndice de umidade\n1\n3000\nInf\n\n\n\nEm seguida, as classes foram combinadas pela soma de cada classe multiplicada por um peso. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1. Desta forma, o número resultante representa um código descrevendo as classes de cada variável. Por exemplo, 1231 é a classe 1 de índice de umidade, 2 de exposição, 3 de TPI e 1 de declividade. Posteriormente, os valores finais foram convertidos em tipos de formas de relevo, seguindo a classificação indicada na Tabela 2.\nTabela 2. Tabela 2. Critério de conversão dos códigos da combinação de classes em tipos de formas de relevo.\n\n\n\nCódigo\nFormas de relevo\n\n\n\n\n10\n11\n\n\n11\n11\n\n\n12\n11\n\n\n13\n13\n\n\n14\n11\n\n\n15\n5\n\n\n20\n21\n\n\n21\n21\n\n\n22\n22\n\n\n23\n24\n\n\n24\n24\n\n\n25\n5\n\n\n31\n30\n\n\n32\n32\n\n\n33\n24\n\n\n34\n24\n\n\n35\n5\n\n\n40\n32\n\n\n41\n32\n\n\n42\n32\n\n\n43\n43\n\n\n44\n3\n\n\n45\n5\n\n\n51\n51\n\n\n111\n11\n\n\n112\n11\n\n\n113\n13\n\n\n114\n3\n\n\n115\n5\n\n\n121\n21\n\n\n122\n22\n\n\n123\n23\n\n\n124\n3\n\n\n125\n5\n\n\n131\n30\n\n\n132\n32\n\n\n133\n23\n\n\n134\n3\n\n\n135\n5\n\n\n141\n32\n\n\n142\n32\n\n\n143\n43\n\n\n144\n3\n\n\n145\n5\n\n\n151\n51\n\n\n211\n11\n\n\n212\n11\n\n\n213\n13\n\n\n214\n4\n\n\n215\n5\n\n\n221\n21\n\n\n222\n22\n\n\n223\n24\n\n\n224\n4\n\n\n225\n5\n\n\n231\n30\n\n\n232\n32\n\n\n233\n24\n\n\n234\n4\n\n\n235\n5\n\n\n241\n32\n\n\n242\n32\n\n\n243\n44\n\n\n244\n4\n\n\n245\n5\n\n\n251\n51\n\n\n1000\n39"
  },
  {
    "objectID": "landforms.html#cálculo-da-variedade-de-formas-de-relevo",
    "href": "landforms.html#cálculo-da-variedade-de-formas-de-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Cálculo da variedade de formas de relevo",
    "text": "Cálculo da variedade de formas de relevo\n\nBases de dados\nClassificamos as formas de relevo utilizando o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), o acúmulo de fluxo do Merit-Hydro (Yamazaki et al. 2019) e a camada de uso do solo do MapBiomas (MapBiomas Project 2020). O Modelo Digital de Elevação possui uma resolução de 90 metros e foi escolhido por ser um produto global ao combinar dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono, T. et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. O Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é principalmente importante para a Floresta Amazônica devido à sua densidade de árvores altas. Além disso, há um produto derivado, o Merit-Hydro, que disponibiliza o acúmulo de fluxo global, que demandaria grande esforço computacional para ser calculado para todo o Brasil. O Merit-Hydro corrige os efeitos de densidade de árvores no cálculo da rede dendrítica, o que é importante para a Amazônia.\nIncluímos as classes de água do MapBiomas para complementar a superfície gerada pelo acúmulo de fluxo na definição de áreas planas úmidas. O MapBiomas é um projeto nacional de mapeamento e classificação de mudanças do uso do solo dos últimos 30 anos a partir de dados de sensoriamento remoto."
  },
  {
    "objectID": "landforms.html#códigos-para-a-criação-da-variedade-de-formas-do-relevo",
    "href": "landforms.html#códigos-para-a-criação-da-variedade-de-formas-do-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Códigos para a criação da variedade de formas do relevo",
    "text": "Códigos para a criação da variedade de formas do relevo\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para replicação da análise pode ser baixado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/1_landforms.ipynb.\n\nDeclividade (slope)\nNós criamos a superfície de declividade a partir do Merit-DEM.\n\n# Importando Modelo Digital de Elevação\n\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\n# Calculando a declividade\n\nslope = ee.Terrain.slope(DEM)\n\n\n\nExposição (aspect)\nNós calculamos a exposição do relevo utilizando o mesmo DEM.\n\naspect = ee.Terrain.aspect(DEM)\n\n\n\nÍndice de Posição Topográfica (TPI)\nNós calculamos o Índice de Posição Topográfica (TPI)(Weiss 2001) para cada célula do raster dentro de um kernel circular com 7, 11 e 15 células de raio. O TPI é a diferença média de elevação entre a célula focal e um conjunto de células vizinhas.\n\\(TPI = \\frac{\\sum_{i}^{n}(vizinhança_i - focal)}{n}\\)\na vizinhança i representa cada uma das n células dentro do kernel da célula focal. O índice final é composto pela média de TPI das três janelas, o que permite a consideração de diferentes níveis de resolução da paisagem, tanto local quanto regional (Theobald et al. 2015). Os tamanhos das janelas foram definidos visualmente para que melhor representassem as formas do relevo, principalmente os Summits, Valleys, Toeslopes e Hilltops (flat e gentle). Os tamanhos das janelas também tinham que capturar os platôs das Chapadas como Summits.\n\n# Função para calcular o TPI\n\ndef calculate_TPI(pixel_size):\n\n  # Calcule a média das células da vizinhança\n\n  focal_mean = DEM.focalMean(**{\n                       'radius': pixel_size,\n                       'kernelType': \"circle\",\n                       'units': \"pixels\"\n                     })\n\n  # Calcule a diferença entre a ćelula focal e média da região \n\n  TPI = focal_mean.subtract(DEM)\n\n  return TPI\n\n\n# Tamanho das janelas \n\nwindow_size = [7,11,15]\n\n# Calculo do TPI para cada janela e calculo do TPI médio das janelas\n\nTPI = ee.ImageCollection(list(map(calculate_TPI, window_size))).toBands().reduce(\"mean\")\n\n\n\nÍndice de umidade (Moisture index)\nNós calculamos o índice de umidade (Anderson et al. 2016) baseado no acúmulo de fluxo presente no Merit-Hydro (Yamazaki et al. 2019), na camada upg, que é calculado sobre o Merit-DEM. O índice de umidade é calculado da seguinte forma:\n\\(moisture.index = \\frac{\\log(fluxo + 1)}{(declividade + 1)} \\times 1000\\)\nonde fluxo é o acúmulo de fluxo e declividade é a calculada anteriormente. O índice de umidade é a média do índice dentro de um kernel circular de uma célula de raio. O tamanho do raio foi escolhido visualmente para suavizar o índice, mas representando bem a distribuição dos cursos d’água.\n\n# Importando o acúmulo de fluxo\n\nflow_accumulation = ee.Image(\"MERIT/Hydro/v1_0_1\").select(\"upg\")\n\n# Calculando o índice de umidade\n\nmoisture_index = (\n    flow_accumulation\n    .add(ee.Number(1))\n    .divide(slope.add(ee.Number(1)))\n    .log()\n    .multiply(1000)\n    .focalMean(**{'radius': 1,\n                  'kernelType': \"circle\",\n                  'units': \"pixels\"\n                  }\n                )\n)"
  },
  {
    "objectID": "landforms.html#convertendo-variáveis-em-classes",
    "href": "landforms.html#convertendo-variáveis-em-classes",
    "title": "Variedade de formas do relevo",
    "section": "Convertendo variáveis em classes",
    "text": "Convertendo variáveis em classes\n\nDeclividade (slope)\nAs variáveis foram convertidas em classes utilizando a Tabela 1, seguindo (Anderson et al. 2016). As classes de declividade foram criadas com o seguinte código:\n\nslope_classes = (\n    slope\n    .where(slope.gte(-1).And(slope.lte(2)), 1)\n    .where(slope.gt(2).And(slope.lte(6)), 2)\n    .where(slope.gt(6).And(slope.lte(24)), 3)\n    .where(slope.gt(24).And(slope.lte(35)), 4)\n    .where(slope.gt(35).And(slope.lte(90)), 5)\n)\n\n\n\nExposição (aspect)\nA exposição foi escolhido para definir as faces quentes e frias no hemisfério sul.\n\naspect_classes = (\n    aspect\n    .where(aspect.gte(0).And(aspect.lte(90)), 2) # face quente\n    .where(aspect.gt(90).And(aspect.lte(270)), 1) # face fria\n    .where(aspect.gt(270).And(aspect.lte(360)), 2) # face quente\n)\n\n\n\nÍndice de Posição do Relevo (TPI)\nAs classes de TPI foram definidas para representarem bem os Summits, Valleys, Toeslopes e Hilltops, que foram as formas do relevo mais difíceis de ajustar os parâmetros.\n\nTPI_classes = (\n    TPI\n    .where(TPI.lte(-15), 1)\n    .where(TPI.gt(-15).And(TPI.lt(-1)), 2)\n    .where(TPI.gte(-1).And(TPI.lte(30)), 3)\n    .where(TPI.gt(30).And(TPI.lte(975)), 4)\n)\n\n\n\nÍndice de Umidade (moisture index)\nO limiar do índice de umidade para classificar as áreas como umidas ou secas foi definido visualmente para capturar a distribuição dos cursos d’água sem criar áreas planas secas com excesso de ramificações dendríticas. Os grandes rios, represas e lagoas (ex. Rio Amazonas) não foram bem representados pelo índice de umidade, pois ele classificava somente as partes mais profundas como áreas úmidas, mantendo o restante dos grandes corpos d’água como regiões planas secas. Nós corrigimos essa classificação combinando a área úmidade classificada pelo acúmulo de fluxo com a classe de águas presente no MapBiomas.\n\n# Classificando o índice de umidade em classes\n\nmoisture_classes = (\n    moisture_index.where(moisture_index.lte(3000), 0)\n    .where(moisture_index.gt(3000), 1)\n)\n\n# Importando o dado de uso de solo do Mapbiomas e reprojetando para a escala do DEM\n\nmapbiomas  = (\n    ee.Image(\"projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2\")\n    .select(\"classification_2020\")\n    .reproject('EPSG:4326', None, 92.76624)\n)\n\n# Reclassificando o raster do MapBiomas em água (1) e outras classes (0)\n\nwater = (\n    mapbiomas\n    .where(mapbiomas.eq(33), 1)\n    .where(mapbiomas.neq(33), 0)\n)\n\n# Combinado o índice de umidade com a camada de água e reclassificando\n\nmoisture_classes = moisture_classes.add(water)\n\nmoisture_classes = (\n    moisture_classes\n    .where(moisture_classes.gte(1), 1)\n    .where(moisture_classes.lt(1), 0)\n)\n\n\n\nCombinando as classes\nCombinamos as classes para gerar um código representativo de cada variável. O índice de umidade foi multiplicado por 1000, exposição por 100, TPI por 10 e declividade por 1.\n\nclasses_collection = ee.Image([moisture_classes.multiply(ee.Number(1000)),\n                                   aspect_classes.multiply(ee.Number(100)),\n                                   TPI_classes.multiply(ee.Number(10)),\n                                   slope_classes])\n\nlandform_combination = classes_collection.reduce(ee.Reducer.sum())\n\n\n\nClassificando as formas do relevo\nClassificamos as formas do relevo pelo código gerado anteriormente e ajustamos visualmente alguns códigos para representarem bem as formas do relevo. Por exemplo, o código 11 representa áreas de baixa inclinação do relevo e uma posição do relevo mais alta que o entorno, sendo portanto um topo de montanha (Summit). No entanto, alguns códigos tiveram que ser bem inspecionados para separar alguns tipos de formas de relevo como Sideslopes de Valleys e Toeslopes.\n\nlandform_types = (\n    landform_combination\n    .mask(landform_combination.gt(0))\n    .where(landform_combination.eq(10), 11)\n    .where(landform_combination.eq(11), 11)\n    .where(landform_combination.eq(12), 11)\n    .where(landform_combination.eq(13), 13)\n    .where(landform_combination.eq(14), 11)\n    .where(landform_combination.eq(15), 5)\n    .where(landform_combination.eq(20), 21)\n    .where(landform_combination.eq(21), 21)\n    .where(landform_combination.eq(22), 22)\n    .where(landform_combination.eq(23), 24)\n    .where(landform_combination.eq(24), 24)\n    .where(landform_combination.eq(25), 5)\n    .where(landform_combination.eq(31), 30)\n    .where(landform_combination.eq(32), 32)\n    .where(landform_combination.eq(33), 24)\n    .where(landform_combination.eq(34), 24)\n    .where(landform_combination.eq(35), 5)\n    .where(landform_combination.eq(40), 32)\n    .where(landform_combination.eq(41), 32)\n    .where(landform_combination.eq(42), 32)\n    .where(landform_combination.eq(43), 43)\n    .where(landform_combination.eq(44), 3)\n    .where(landform_combination.eq(45), 5)\n    .where(landform_combination.eq(51), 51)\n    .where(landform_combination.eq(111), 11)\n    .where(landform_combination.eq(112), 11)\n    .where(landform_combination.eq(113), 13)\n    .where(landform_combination.eq(114), 3)\n    .where(landform_combination.eq(115), 5)\n    .where(landform_combination.eq(121), 21)\n    .where(landform_combination.eq(122), 22)\n    .where(landform_combination.eq(123), 23)\n    .where(landform_combination.eq(124), 3)\n    .where(landform_combination.eq(125), 5)\n    .where(landform_combination.eq(131), 30)\n    .where(landform_combination.eq(132), 32)\n    .where(landform_combination.eq(133), 23)\n    .where(landform_combination.eq(134), 3)\n    .where(landform_combination.eq(135), 5)\n    .where(landform_combination.eq(141), 32)\n    .where(landform_combination.eq(142), 32)\n    .where(landform_combination.eq(143), 43)\n    .where(landform_combination.eq(144), 3)\n    .where(landform_combination.eq(145), 5)\n    .where(landform_combination.eq(151), 51)\n    .where(landform_combination.eq(211), 11)\n    .where(landform_combination.eq(212), 11)\n    .where(landform_combination.eq(213), 13)\n    .where(landform_combination.eq(214), 4)\n    .where(landform_combination.eq(215), 5)\n    .where(landform_combination.eq(221), 21)\n    .where(landform_combination.eq(222), 22)\n    .where(landform_combination.eq(223), 24)\n    .where(landform_combination.eq(224), 4)\n    .where(landform_combination.eq(225), 5)\n    .where(landform_combination.eq(231), 30)\n    .where(landform_combination.eq(232), 32)\n    .where(landform_combination.eq(233), 24)\n    .where(landform_combination.eq(234), 4)\n    .where(landform_combination.eq(235), 5)\n    .where(landform_combination.eq(241), 32)\n    .where(landform_combination.eq(242), 32)\n    .where(landform_combination.eq(243), 44)\n    .where(landform_combination.eq(244), 4)\n    .where(landform_combination.eq(245), 5)\n    .where(landform_combination.eq(251), 51)\n    .where(landform_combination.gte(1000), 39)\n)\n\n\n\nExportando mapas para assets\n\n# Nome do asset\nassetId = \"projects/ee-lucasljardim9/assets/landform_types\"\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nescala = landform_types.projection().nominalScale()\n\n\n# Exportando para o gee\ngeemap.ee_export_image_to_asset(\n    landform_types, description='landform_types', assetId=assetId, region=regiao_box, scale=escala,maxPixels=1e13\n)\n\n\n\nExemplo de formas de relevo\nAbaixo está uma representação das formas de relevo na região de Alto Paraíso de Goiás-GO (Latitude:-14.11, Longitude:-47.26).\n\n%%capture --no-display\n#| echo: false\n\n# Delimitando a região\nbb = ee.Geometry.BBox(-47.4631, -13.9777, -47.1005, -14.1711)\n\n# Creando a pasta para exportar as figuras\nif not os.path.exists(\"figura\"):\n    \n    os.mkdir(\"figura\")\n\n# Exportando a imagem da região\ngeemap.ee_export_image(\n    landform_types, filename=\"figura/landform_types.tif\", scale=escala, region=bb, file_per_band=False\n)\n\n\n# Paleta de cores das formas de relevo\npalette = [\n    \"#ffc408\", # 3\n    \"#ffa101\", # 4\n    \"#ef595a\", # 5\n    \"#ffbdbe\", # 11\n    \"#6e4100\", # 13\n    \"#af7b53\", # 21\n    \"#c8f6ad\", # 23\n    \"#c8c284\", # 22\n    \"#83e763\", # 24\n    \"#08a702\", # 43\n    \"#ffffbe\", # 30\n    \"#a9a800\", # 32\n    \"#b671f2\", # 39\n    \"#0a7000\" ] # 44\n\n# Discretinzando a paleta de cores\ncmap = ListedColormap(\n   palette, 'Custom cmap')\n\nclass_bins = [3, 4, 5, 11, 13, 21, 22, 23, 24, 30, 32, 39, 43, 45]\n\nnorm = BoundaryNorm(class_bins, \n                    13)\n\n# Plotando mapa \ngeemap.plot_raster(\"figura/landform_types.tif\", cmap = cmap, norm = norm, figsize = [20, 10])\n\n      Figura 2. Formas de relevo classificadas na região de Alto Paraíso de Goiás-GO, Brasil."
  },
  {
    "objectID": "landforms.html#calculando-a-variedade-de-formas-de-relevo",
    "href": "landforms.html#calculando-a-variedade-de-formas-de-relevo",
    "title": "Variedade de formas do relevo",
    "section": "Calculando a variedade de formas de relevo",
    "text": "Calculando a variedade de formas de relevo\nA variedade de formas do relevo foi calculada como a soma dos tipos de formas dentro de um kernel circular de uma célula focal. O tamanho do raio do kernel foi definido calculando a variedade em diferentes raios (2, 5, 7, 10, 15, 20 células) e calculando o ganho de variedade a cada aumento de raio. O raio escolhido foi aquele no qual o raio subsequente não adicionou variedade. Dessa forma, o raio representa o nível de resolução da paisagem que captura o máximo de variedade de formas do relevo. Raios maiores podem aumentar a variedade, mas devido a mudança de paisagem. Assim, o raio escolhido foi de 5 células de raio (450 metros) para todo o Brasil. Abaixo está uma representação da variedade de formas do relevo para a mesma região de Alto Paraíso de Goiás-GO.\n\nradius_pixels = 5\n\nlandform_variety = (\n    landform_types\n    .neighborhoodToBands(ee.Kernel.circle(radius_pixels))\n    .reduce(ee.Reducer.countDistinct())\n)\n\n\n%%capture --no-display\n\ngeemap.ee_export_image(\n    landform_variety, filename=\"figura/landform_variety.tif\", scale=escala, region=bb, file_per_band=False\n)\n\n\ngeemap.plot_raster(\"figura/landform_variety.tif\", figsize = [20, 10])\n\n        Figura 3. Variedade de formas de relevo para região de Alto Paraíso de Goiás-GO, Brasil.\n\n# modifique o assetId para o endereço do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landform_variety\"\n\ngeemap.ee_export_image_to_asset(\n    landform_variety, \n    description='landform_variety', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,maxPixels=1e13\n)"
  },
  {
    "objectID": "landforms.html#conferir-a-criação-do-asset",
    "href": "landforms.html#conferir-a-criação-do-asset",
    "title": "Variedade de formas do relevo",
    "section": "Conferir a criação do asset",
    "text": "Conferir a criação do asset\nO asset pode demorar algumas horas para ser criado. Para conferir se o asset foi criado, rode a linha de comando abaixo. O código busca o nome do asset na nuvem do GEE. Se não funcionar, confira aqui como instalar as funções para uso da linha de comando.\n\nos.system(f\"earthengine ls projects/ee-lucasljardim9/assets| grep 'assets/landform_variety'\")\n\nOutra possibilidade é acessar a página do editor de código do GEE e na parte direita da tela, em Tasks, confira se o processo de criação finalizou com sucesso, colorido em azul. Vermelho indica que houve algum erro durante o processo.\n\nTambém é possível ver os assets na aba Assets, na parte esquerda da tela.\n\nVeja o dado criado com:\n\n# Paleta de cores\nsld_intervals =(\n'&lt;RasterSymbolizer&gt;' + \\\n  '&lt;ColorMap type=\"intervals\" extended=\"False\"&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffc408\" quantity=\"3\" label=\"Cool Steep Slope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffa101\" quantity=\"4\" label=\"Warm Steep Slope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ef595a\" quantity=\"5\" label=\"Cliff\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffbdbe\" quantity=\"11\" label=\"Summit/Ridgetop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#6e4100\" quantity=\"13\" label=\"Slope Crest\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#af7b53\" quantity=\"21\" label=\"Flat Hilltop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#c8c284\" quantity=\"22\" label=\"Gentle Slope Hilltop\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#c8f6ad\" quantity=\"23\" label=\"Cool Sideslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#83e763\" quantity=\"24\" label=\"Warm Sideslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#ffffbe\" quantity=\"30\" label=\"Dry Flats\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#a9a800\" quantity=\"32\" label=\"Valley/Toeslope\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#b671f2\" quantity=\"39\" label=\"Moist Flats\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#08a702\" quantity=\"43\" label=\"Cool Footslope/Cove\"/&gt;' + \\\n    '&lt;ColorMapEntry color=\"#0a7000\" quantity=\"44\" label=\"Warm Footslope/Cove\"/&gt;' + \\\n  '&lt;/ColorMap&gt;' + \\\n'&lt;/RasterSymbolizer&gt;')\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe o asset\n\nvariedade = ee.Image(\"projects/ee-lucasljardim9/assets/landform_types\")\n\n# Plote o mapa\n\nMap.addLayer(variedade.sldStyle(sld_intervals)) \n\n\nMap"
  },
  {
    "objectID": "instalacao.html",
    "href": "instalacao.html",
    "title": "Instalação e ambiente para as análises",
    "section": "",
    "text": "As análises deste tutorial foram rodadas no Google Earth Engine (GEE) utilizando como interface o pacote geemap em Python. O tutorial está escrito no JupyterNotebook. Dessa forma, para a reprodução das análises é necessário a criação de uma conta no GEE. Em seguida, instale o Python, se não estiver instalado. Com o Python instalado, instale o JupyterNotebook. Por fim, instale o pacote geemap.\nAlguns pacotes auxiliares também são usados para produzir e exportar figuras como os e matplotlib. Escreva na linha de comando os seguintes códigos para instalar:\npip install os\n\npip install matplotlib\n\npip install pyxarray\n\npip install rioxarray"
  },
  {
    "objectID": "instalacao.html#bases-importadas",
    "href": "instalacao.html#bases-importadas",
    "title": "Instalação e ambiente para as análises",
    "section": "Bases importadas",
    "text": "Bases importadas\n\nArquivo vetorial dos biomas do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Biome.\n\nArquivo matricial com a classificação de áreas úmidas global produzido pelo Sustainable Wetlands Adaptation and Mitigation Program ( SWAMP ), Center for International Forestry Research (CIFOR) e United States Forest Service.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Cifor_wetlands.\n\nArquivo vetorial de pedologia do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/pedo_area.\n\nArquivo matricial da conectividade local produzido neste projeto utilizando o Omniscape.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness."
  },
  {
    "objectID": "instalacao.html#base-importada-do-mapbiomas",
    "href": "instalacao.html#base-importada-do-mapbiomas",
    "title": "Instalação e ambiente para as análises",
    "section": "Base importada do MapBiomas",
    "text": "Base importada do MapBiomas\nhttps://code.earthengine.google.com/?asset=projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2."
  },
  {
    "objectID": "instalacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "href": "instalacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "title": "Instalação e ambiente para as análises",
    "section": "Bases disponibilizadas pelo catálogo do Google Earth Engine",
    "text": "Bases disponibilizadas pelo catálogo do Google Earth Engine\n\nModelo Digital de Elevação\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_DEM_v1_0_3\n\n\nAcúmulo de fluxo\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_Hydro_v1_0_1"
  },
  {
    "objectID": "instalacao.html#dados-produzidos-pelas-análises",
    "href": "instalacao.html#dados-produzidos-pelas-análises",
    "title": "Instalação e ambiente para as análises",
    "section": "Dados produzidos pelas análises",
    "text": "Dados produzidos pelas análises\n\nVariedade de formas de relevo\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landform_variety\n\n\nAmplitude altitudinal\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/elevation_range_residual\n\n\nQuantidade de áreas úmidas\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_count\n\n\nDensidade de áreas úmidas local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density\n\n\nDensidade de áreas úmidas regional\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density_1000\n\n\nRiqueza de solos\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/soil_diversity\n\n\nValores de Z das variáveis\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_landform_variety\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_elevation_range\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_wetlands_score\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_soil_diversity\n\n\nHeterogeneidade da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landscape_heterogeneity\n\n\nConectividade local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness\n\n\nResiliência da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/resilience"
  },
  {
    "objectID": "elevation_range.html",
    "href": "elevation_range.html",
    "title": "Amplitude altitudinal",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "href": "elevation_range.html#importando-pacotes-e-inicializando-geemap",
    "title": "Amplitude altitudinal",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()"
  },
  {
    "objectID": "elevation_range.html#cálculo-da-amplitude-altitudinal",
    "href": "elevation_range.html#cálculo-da-amplitude-altitudinal",
    "title": "Amplitude altitudinal",
    "section": "Cálculo da amplitude altitudinal",
    "text": "Cálculo da amplitude altitudinal\nA amplitude altitudinal foi calculada como a diferença entre a altitude máxima e mínima dentro da vizinhaça da célula focal. Como essa métrica é correlacionada com a variedade de formas de relevo, nós calculamos o resíduos de uma regressão (Ordinary Least Squares) entre as duas váriaveis (Anderson et al. 2016). Assim, a amplitude altitudinal residual é independente da variedade de formas de relevo. Isso permite a identificação de locais que tenham maior variabilidade microclimática que aquela proporcionada pela variedade de formas de relevo, quando calcularmos o índice de diversidade da paisagem."
  },
  {
    "objectID": "elevation_range.html#base-de-dados",
    "href": "elevation_range.html#base-de-dados",
    "title": "Amplitude altitudinal",
    "section": "Base de dados",
    "text": "Base de dados\nUtilizamos o Modelo Digital de Elevação (DEM) do Merit-DEM (Yamazaki et al. 2017), na escala de 90 metros. O Merit-DEM é um produto global que combina dados dos satélites do Shuttle Radar Topography Mission (SRTM) (Farr et al. 2007) e Advanced Land Observing Satellite (ALOS) (Tadono, T. et al. 2014), permitindo a replicabilidade da metodologia em outras regiões. Além disso, o Merit-DEM corrige viéses de Modelo Digitais de Elevação gerados por imagens de satétite como speckle noise, stripe noise, absolute bias e tree height bias (Yamazaki et al. 2017). A correção de tree height bias é especialmente importante para a Floresta Amazônica devido à sua densidade de árvores altas.\nA variedade de formas de relevo foi calculada anteriormente (veja o capítulo Variedade de formas de relevo) e está disponível como um asset em https://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landform_variety.\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido à demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/2_elevation_range.ipynb."
  },
  {
    "objectID": "elevation_range.html#códigos-para-o-cálculo-da-amplitude-altitudinal-residual",
    "href": "elevation_range.html#códigos-para-o-cálculo-da-amplitude-altitudinal-residual",
    "title": "Amplitude altitudinal",
    "section": "Códigos para o cálculo da amplitude altitudinal residual",
    "text": "Códigos para o cálculo da amplitude altitudinal residual\nPrimeiro, importamos um vetor dos biomas do Brasil para extrairmos as coordenadas mínimas e máximas do Brasil.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\nImportamos os rasters do modelo digital de elevação e da variedade de formas de relevo e definimos a resolução da análise como aquela do modelo digital de elevação.\n\n# Importando o modelo digital de elevação\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# Importando a variedade de landforms calculada anteriormente\n# modifique o endereço para o do seu projeto\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\n#Escala dos rasters ~92 metros\nescala = DEM.projection().nominalScale()\n\nExtraímos do raster as células dentro da vizinhança (kernel circular com 5 células de raio, ~450 metros) da célula focal e salvamos como bandas de uma imagem. Assim, cada banda é um stack das células da vizinhança da célula focal, a primeira banda possui todas as primeiras células de cada célula focal, a segunda banda todas as segunda células, e assim por diante.\n\n# Tamanho do raio do kernel para o calculo da amplitude altitudinal\nradius_pixels = 5\n\n# Criando rasters da vizinhança de cada célula como bandas da imagem\nneighbor = DEM.neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels)))\n\nO raster neighbor criado acima possui as células da vizinhança como bandas. Assim, as primeiras células de cada banda são as células da vizinhança da primeira célula focal, organizadas como colunas (bandas). Ao calcularmos os valores máximos e mínimos para cada coluna de neighbor, estamos calculando os valores máximos e mínimos da vizinhança de cada célula focal.\n\n# Calcule o máximo da vizinhança\nelevation_max = neighbor.reduce(ee.Reducer.max())\n\n# Calcule o mínimo da vizinhança\nelevation_min = neighbor.reduce(ee.Reducer.min())\n\nSubtraindo os valores máximos e mínimos de cada célula focal e calculando o seu valor absoluto, temos a amplitude altitudinal para cada célula focal. Nós salvamos a amplitude altitudinal e variedade de formas de relevo como um raster com duas bandas, sendo a primeira banda a variável preditora da regressão e a segunda banda a variável resposta.\n\n# Calcule a amplitude da vizinhança\nelevation_range = elevation_max.subtract(elevation_min).abs()\n\n# Crie uma imagem com as bandas de varidedade de formas de relevo e amplitude altitudinal \n# A primeira imagem é o x da regressão e a segunda é o y\n\nelevation = (ee.Image.cat(landform_variety, elevation_range)\n            .rename(['landform_variety', 'elevation_range']))\n\nDessa forma, aplicamos a regressão entre as variáveis.\n\n# Rode uma regressão linear (OLS) entre varidade formas de relevo e amplitude altitudinal\nregression = elevation.reduceRegion(**{\n     'reducer': ee.Reducer.linearFit(),\n     'geometry': regiao_box,\n     'maxPixels': 1e13,\n     'scale': escala\n    })\n\nApós a regressão, multiplicamos a variável preditora pelo coeficiente de regressão (slope) e adicionamos o valor do intercepto para predizermos os valores de amplitude altitudinal esperados pela regressão. Em seguida, subtraímos os valores de amplitude altitudinal pelos valores preditos pela regressão para calcularmos os resíduos do modelo.\n\n# Calcule o valor predito, pela regressão, de amplitude altitudinal, sem intercepto \npred = elevation.select('landform_variety').multiply(ee.Number(regression.get('scale')))\n\n# Adicione o intercepto na predição\npredict = pred.add(ee.Number(regression.get('offset')))\n\n# Calcule o residuo da regressão\nresiduals = elevation.select('elevation_range').subtract(predict).rename(['residuals'])\n\nPor fim, exportamos o raster de amplitude altitudinal residual como um asset do Google Earth Engine.\n\n# Exporte a amplitude altitudinal residual como asset\n# modifique o assetId para o do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/elevation_range_residual\"\n\ngeemap.ee_export_image_to_asset(\n    residuals, \n    description='elevation_range_residual', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\nO dado criado pode ser visualizado abaixo:\n\n# Paleta de cores\n\npalette = cm.get_palette('terrain', n_class=10)\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe o asset\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/elevation_range_residual\")\n\n# Plote o mapa\n\nMap.addLayer(elevation_range, {'palette':palette, 'min':0, 'max': 479}) \n\n\nMap"
  },
  {
    "objectID": "wetland_score.html",
    "href": "wetland_score.html",
    "title": "Índice de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nO índice de áreas úmidas é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. O índice de áreas úmidas entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de formas de relevo e baixa amplitude altitudinal. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente (Anderson et al. 2016).\nExistem três cenários de distribuição de áreas úmidas:\n\n\nOs locais estão presentes em áreas com alta densidade de áreas úmidas no entorno,\n\n\nOs locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente,\n\n\nOs locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial.\n\n\nDessa forma, o índice de áreas úmidas é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local) (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNeste capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e no capítulo Z_scores mostraremos como calculamos os valores de Z e o índice de áreas úmidas."
  },
  {
    "objectID": "wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "href": "wetland_score.html#importando-pacotes-e-inicializando-geemap",
    "title": "Índice de áreas úmidas",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nO índice de áreas úmidas é uma combinação da densidade de áreas úmidas localmente com a densidade e quantidade de áreas úmidas regionalmente. O índice de áreas úmidas entra no cálculo da diversidade da paisagem em locais planos e úmidos, com baixa variedade de formas de relevo e baixa amplitude altitudinal. Nesses locais a variação microclimática seria baixa devido a baixa variabilidade topográfica e geomorfológica, mas como há alta densidade de áreas úmidas, esses locais atuam regulando a variabilidade microclimática localmente (Anderson et al. 2016).\nExistem três cenários de distribuição de áreas úmidas:\n\n\nOs locais estão presentes em áreas com alta densidade de áreas úmidas no entorno,\n\n\nOs locais estão situados em áreas com baixa densidade de áreas úmidas localmente, mas alta densidade regionalmente,\n\n\nOs locais estão presentes em áreas com alta quantidade de áreas úmidas, mas baixa densidade devido a sua distribuição espacial.\n\n\nDessa forma, o índice de áreas úmidas é composto pelos três cenários citados anteriormente, primeiro é calculado a densidade local, regional e a quantidade regional e, para cada métrica, é calculado um valor de Z, subtraindo pela média e dividindo pelo desvio padrão. A densidade de áreas úmidas é a média ponderada dos valores de Z da densidade local e regional (peso duplo para a densidade local). Nos locais onde os valores de Z da quantidade de áreas úmidas regional é maior que a densidade média calculada anteriormente, o índice torna-se a média ponderada da densidade local, densidade regional e quantidade de áreas úmidas regional (duplo peso para a densidade local) (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]\nNeste capítulo demonstraremos como as densidades e a quantidade de áreas úmidas foram calculadas e no capítulo Z_scores mostraremos como calculamos os valores de Z e o índice de áreas úmidas."
  },
  {
    "objectID": "wetland_score.html#banco-de-dados",
    "href": "wetland_score.html#banco-de-dados",
    "title": "Índice de áreas úmidas",
    "section": "Banco de dados",
    "text": "Banco de dados\nUtilizamos como base de dados de áreas úmidas o Global Wetlands database (Gumbricht et al. 2017). Reprojetamos o raster de áreas úmidas para a mesma resolução do modelo digital de elevação usado nas etapas anteriores (~ 92 metros).\nRetiramos as áreas úmidas classificadas como sistemas lacustres e ribeirinhos (riverines e lacustrines) e reclassificamos o raster como sendo área úmida (1) ou não sendo área úmida (0). Depois, calculamos a densidade de áreas úmidas dentro de uma vizinhaça de 450 metros (5 células) de raio de um kernel circular (densidade local). Calculamos também a densidade e a quantidade de áreas úmidas na vizinhança de ~ 1170 metros (13 células) (regional)."
  },
  {
    "objectID": "wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "href": "wetland_score.html#código-para-calcular-as-densidades-e-quantidade-de-áreas-úmidas",
    "title": "Índice de áreas úmidas",
    "section": "Código para calcular as densidades e quantidade de áreas úmidas",
    "text": "Código para calcular as densidades e quantidade de áreas úmidas\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/3_wetland_score.ipynb.\nPrimeiro, nós importamos os polígonos dos biomas do Brasil e extraímos suas coordenadas geográficas máximas e mínimas para delimitar a região de análise. Importamos o modelo digital de elevação e o raster de áreas úmidas e reprojetamos a resolução das áreas úmidas para a resolução do modelo digital de elevação.\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas \n# mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\n# Reprojetando áreas úmidas\nwetlands = (ee.Image(\"projects/ee-lucasljardim9/assets/Cifor_wetlands\") \n            .reproject(**{'crs': \"EPSG:4326\",\n                       'scale': escala}))\n\nEm seguida, retiramos os sistemas ribeirinhos e lacustres do raster de áreas úmidas e reclassificamos as classes do raster em presença e ausência de áreas úmidas.\n\n# Criando uma máscara para rios e lagos\n\nrivers = wetlands.mask(wetlands.neq(10))\n\n# Retirando rios e lagos das áreas úmidas\n\nwetlands = wetlands.mask(rivers)\n\n# Transformando áreas úmidas em um raster binário\n# de presença de áreas úmidas\n\nwetlands_binary = wetlands.where(wetlands.gt(0), 1).unmask()\n\nPosteriomente, calculamos a densidade de áreas úmidas, localmente, dentro de um kernel circular de ~450 metros (5 células). Primeiro, transformamos as células da vizinhança de cada célula focal em bandas de uma imagem. Assim, cada células vizinha da célula focal fica empilhada como uma coluna. Para cada coluna, somamos os valores das células (0 ou 1) como a quantidade de áreas úmidas na vizinhança. Depois, dividimos a quantidade de áreas úmidas pelo número de células na vizinhança, resultando na densidade de áreas úmidas.\n\nradius_pixels = 5\n\n# Tranforme as células da vizinha em bandas\n\nneighbors = (wetlands_binary\n            .neighborhoodToBands(ee.Kernel.circle(ee.Number(radius_pixels))))\n\n# Conte a quantidade de áreas úmidas na vizinhança\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\n\nneighbors_amount = neighbors.bandNames().length()\n\n#Divida a quantidade de áreas úmidas pelo \n# número de células para calcular a densidade \nwetlands_density_local = wetlands_count.divide(ee.Number(neighbors_amount))\n\nRepetimos o mesmo procedimento conduzido para a densidade local para calcularmos a densidade e quantidade de áreas úmidas regional.\n\nradius_pixels = 13\n\n# Transforme as células vizinhas em bandas\n\nneighbors = (wetlands_binary\n           .neighborhoodToBands(ee.Kernel.circle(\n                                   ee.Number(radius_pixels)\n                                   )\n                               ))\n\n# Conte a quantidade de áreas úmidas\nwetlands_count = neighbors.reduce(ee.Reducer.sum()).toDouble()\n\n# Conte o número de células totais na vizinhança\nneighbors_amount = neighbors.bandNames().length()\n\n# Calcule a densidade dividindo a quantidade \n# de áreas úmidas pelo número de células\nwetlands_density_regional = wetlands_count.divide(ee.Number(neighbors_amount))\n\nPor fim, exportamos a densidade de áreas úmidas local (wetlands_density), a densidade regional (wetlands_density_1000) e a quantidade regional (wetlands_count) como assets no Google Earth Engine.\n\n# modifique os assetIds para os do seu projeto\n\nassetId_quantidade = \"projects/ee-lucasljardim9/assets/wetlands_count\"\n\nassetId_densidade_local = \"projects/ee-lucasljardim9/assets/wetlands_density\"\n\nassetId_densidade_regional = \"projects/ee-lucasljardim9/assets/wetlands_density_1000\"\n\ngeemap.ee_export_image_to_asset(\n    wetlands_count, \n    description='wetlands_count', \n    assetId=assetId_quantidade, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_local, \n    description='wetlands_density_local', \n    assetId=assetId_densidade_local, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    wetlands_density_regional, \n    description='wetlands_density_regional', \n    assetId=assetId_densidade_regional, \n    region=regiao_box, \n    scale=escala, maxPixels=1e13\n)\n\nOs dados criados podem ser visualizados como abaixo:\n\n# Paleta de cores\n\npalette = cm.get_palette('terrain', n_class=10)\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe os assets\n\nwetlands_count = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_count\")\n\nwetlands_density_local = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density\")\n\nwetlands_density_regional = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density_1000\")\n\n\n# Plote o mapa\n\nMap.addLayer(wetlands_count, {'palette':palette, 'min':0, 'max': 1}, \"wetlands count\") \nMap.addLayer(wetlands_density_local, {'palette':palette, 'min':0, 'max': 1}, \"local density\") \nMap.addLayer(wetlands_density_regional, {'palette':palette, 'min':0, 'max': 1}, \"regional density\") \n\n\n\nMap"
  },
  {
    "objectID": "soil_diversity.html",
    "href": "soil_diversity.html",
    "title": "Riqueza de solos",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nA riqueza de solos é calculada como a quantidade de componentes da unidade de mapeamento de solos."
  },
  {
    "objectID": "soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "href": "soil_diversity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Riqueza de solos",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nA riqueza de solos é calculada como a quantidade de componentes da unidade de mapeamento de solos."
  },
  {
    "objectID": "soil_diversity.html#banco-de-dados",
    "href": "soil_diversity.html#banco-de-dados",
    "title": "Riqueza de solos",
    "section": "Banco de Dados",
    "text": "Banco de Dados\nUtilizamos a base de dados de pedologia do Instituto Brasileiro de Geografia e Estatística (IBGE) (https://geoftp.ibge.gov.br/informacoes_ambientais/pedologia/vetores/escala_250_mil/versao_2023/pedo_area.zip) para o cálculo da riqueza de solos. Utilizamos o arquivo pedo_area.shp. Calculamos a quantidade de solos componentes de cada polígono e rasterizados na escala do modelo digital de elevação utilizado nas etapas anteriores (~ 92 metros)."
  },
  {
    "objectID": "soil_diversity.html#códigos-para-a-criação-da-riqueza-de-solos",
    "href": "soil_diversity.html#códigos-para-a-criação-da-riqueza-de-solos",
    "title": "Riqueza de solos",
    "section": "Códigos para a criação da riqueza de solos",
    "text": "Códigos para a criação da riqueza de solos\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017) , devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020), em Python (Python Software Foundation 2023), como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/4_soil_diversity.ipynb.\nO primeiro passo é criar uma função que conta os tipos de solos componentes de cada polígono. Concatenamos as colunas componente, component1, component2 e component3. Depois, separamos a string pelos sinais de “+”, que indicam as separações das descrições de cada tipo de solo. Em seguida, contamos quantos tipo de solos existem em cada polígono como o comprimento da lista de tipos de solos. Adicionamos uma coluna chamada soil_richness com a riqueza de solos em cada polígono.\n\ndef fun(feature):\n    number = (ee.String(feature.get(\"componente\"))\n              .cat(ee.String(feature.get(\"component1\")))\n              .cat(ee.String(feature.get(\"component2\")))\n              .cat(ee.String(feature.get(\"component3\")))\n              .split(\"\\+\")\n              .length())\n\n    return feature.set(\"soil_richness\", number)\n\nEm seguida, importamos os dados de solo, definimos a região para exportar o dado e a escala da análise.\n\n# Importando os polígonos de solo\nsolo = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/pedo_area\")\n\n# Importando mapa de biomas do IBGE para extrair as coordenadas mínimas e máximas do Brasil\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Extraindo a resolução do mapa\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\") \n\nescala = DEM.projection().nominalScale()\n\nAplicamos a função criada anteriormente aos polígonos de solo.\n\nsolo = solo.map(fun)\n\nRasterizamos a riqueza de solos na mesma escala das análises anteriores.\n\nsoil_diversity = solo.reduceToImage(**{'properties':[\"soil_richness\"],\n                     'reducer':ee.Reducer.max()}) \\\n                     .reproject(**{'crs':\"EPSG:4326\",\n                                  'scale':escala})\n\nPor fim, exportamos o raster como um asset no Google Earth Engine.\n\n# Exporte o raster de riqueza de solo \n#modifique o assetId para do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/soil_diversity\"\n\ngeemap.ee_export_image_to_asset(\n    soil_diversity, description='soil_diversity', assetId=assetId, region=regiao_box, scale=escala, maxPixels=1e13\n)\n\nO dado criado pode ser visualizado abaixo:\n\n# Paleta de cores\n\npalette = cm.get_palette('terrain', n_class=10)\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe os assets\n\nsoil_diversity = ee.Image(\"projects/ee-lucasljardim9/assets/soil_diversity\")\n\n\n# Plote o mapa\n\nMap.addLayer(soil_diversity, {'palette':palette, 'min':0, 'max': 6}) \n\n\nMap"
  },
  {
    "objectID": "Z_scores.html",
    "href": "Z_scores.html",
    "title": "Valor de Z das variáveis",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\ngeemap.ee_initialize()"
  },
  {
    "objectID": "Z_scores.html#cálculo-do-valor-de-z",
    "href": "Z_scores.html#cálculo-do-valor-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Cálculo do valor de Z",
    "text": "Cálculo do valor de Z\nAntes de calcularmos a diversidade da paisagem e a resiliência, nós transformamos as variáveis (variedade de formas de relevo, amplitude altitudinal, densidade, quantidade de áreas úmidas e riqueza de solo) em valores de Z (Anderson et al. 2016). O cálculo de Z é realizado dentro das janelas móveis. Um fato importante é a posterior tranformação dos valores de densidade e quantidade de áreas úmidas em índice de áreas úmidas.\nOs valores de Z de cada variável, em cada célula (i), é o desvio do valor da célula da média da janela móvel (u), divido pelo seu desvio padrão:\n\\[Z-score_{iu} = \\frac{i - media_{u}}{desviopadrao_{u}}\\]"
  },
  {
    "objectID": "Z_scores.html#índice-de-áreas-úmidas",
    "href": "Z_scores.html#índice-de-áreas-úmidas",
    "title": "Valor de Z das variáveis",
    "section": "Índice de áreas úmidas",
    "text": "Índice de áreas úmidas\nO índice de áreas úmidas é a média ponderada das densidades locais e regionais de áreas úmidas. Em locais onde o valor de Z da densidade média é menor que o Z da quantidade de áreas úmidas, o índice de áreas úmidas assume o segundo valor Z (Anderson et al. 2016).\n\\[\n\\tiny\níndice\\ de\\ áreas\\ úmidas =\n  \\begin{cases}  \n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z)}{3} & \\text{se densidade média é maior ou igual à quantidade regional}\\\\\n    \\frac{2 \\times densidade_{local}(Z) + densidade_{regional}(Z) + quantidade_{regional}(Z)}{4}& \\text {se a quantidade regional for maior a densidade média}\n  \\end{cases}\n\\]"
  },
  {
    "objectID": "Z_scores.html#base-de-dados",
    "href": "Z_scores.html#base-de-dados",
    "title": "Valor de Z das variáveis",
    "section": "Base de dados",
    "text": "Base de dados\nUtilizamos as variáveis criadas anteriormente e guardadas como assets no Google Earth Engine. As variáveis são:\n\nvariedade de formas de relevo\namplitude altitudinal\nriqueza de solo\ndensidade local de áreas úmidas\ndensidade regional de áreas úmidas\nquantidade regional de áreas úmidas"
  },
  {
    "objectID": "Z_scores.html#códigos-para-o-cálculo-dos-valores-de-z",
    "href": "Z_scores.html#códigos-para-o-cálculo-dos-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Códigos para o cálculo dos valores de Z",
    "text": "Códigos para o cálculo dos valores de Z\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para reprodução da análise pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/5_Z_scores.ipynb.\nPrimeiro, criamos uma função para calcular o valor de Z dentro de cada janela móvel (code) para cada variável (image). A função calcula a média e desvio padrão para a vizinhança de cada célula, utilizando uma janela móvel circular. Depois, os valores e média e desvio padrão convertidos para valores de Z pela subtração da variável pela média e divida pelo desvio padrão.\n\ndef calculate_Z_scores(image, windows):\n\n  # Calculando a média\n  mean = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.mean(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Calculando o desvio padrão\n  sd = image.reduceNeighborhood(**{\n    'reducer': ee.Reducer.stdDev(),\n    'kernel': ee.Kernel.circle(**{\n                                'radius':windows,\n                                'units':'pixels',\n                                'normalize':False\n                              }),\n  })\n\n  # Renomeie os rasters\n  meanValue = mean.rename('mean')\n  sdValue = sd.rename('sd')\n\n  # Calculando os valores de Z\n  z = image.subtract(meanValue).divide(sdValue).rename('z')\n\n  return z\n\nO próximo passo é importar as variáveis de interesse para o cálculo de Z.\n\n# Importando as variáveis\n\n# modificar os endereços para os dos projetos\n\nlandform_variety = ee.Image(\"projects/ee-lucasljardim9/assets/landform_variety\")\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/elevation_range_residual\")\n\nsoil_diversity = ee.Image('projects/ee-lucasljardim9/assets/soil_diversity')\n\n\n# Importando os dados de wetlands para o wetland score\n\nwetlands_count = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_count\")\n\nwetlands_density = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density\")\n\nwetlands_density_1000 = ee.Image(\"projects/ee-lucasljardim9/assets/wetlands_density_1000\")\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()"
  },
  {
    "objectID": "Z_scores.html#calculando-os-valores-de-z",
    "href": "Z_scores.html#calculando-os-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Calculando os valores de Z",
    "text": "Calculando os valores de Z\nNós aplicamos a função calculate_Z_scores para cada variável e guardamos o valores de Z calculados.\n\n# Definindo a janela para o cálculo do do Z \nwindows = 200\n\n# Calculando os valores de Z para cada variável\nZ_landform_variety = calculate_Z_scores(landform_variety, windows)\n\nZ_elevation_range = calculate_Z_scores(elevation_range, windows)\n\nZ_soil_diversity = calculate_Z_scores(soil_diversity, windows)\n\nZ_wetlands_count = calculate_Z_scores(wetlands_count, windows)\n\nZ_wetlands_density = calculate_Z_scores(wetlands_density, windows)\n\nZ_wetlands_density_1000 = calculate_Z_scores(wetlands_density_1000, windows)"
  },
  {
    "objectID": "Z_scores.html#calculando-índice-de-áreas-úmidas",
    "href": "Z_scores.html#calculando-índice-de-áreas-úmidas",
    "title": "Valor de Z das variáveis",
    "section": "Calculando índice de áreas úmidas",
    "text": "Calculando índice de áreas úmidas\nAqui, nós calculamos o índice de áreas úmidas, aplicando a fórmula descrita anteriormente.\n\n# Calculando a densidade de areas úmidas como a média do local e regional\nwetlands_density = (Z_wetlands_density\n                    .multiply(2)\n                    .add(Z_wetlands_density_1000)\n                    .divide(3))\n\n# Testando se o Z da quantidade de áreas úmidas é maior que a densidade média\n\nwet_test = wetlands_density.lt(Z_wetlands_count)\n\n# Média de densidade local, regional e quantidade de áreas úmidas\nwet_average = (wetlands_density\n              .multiply(3)\n              .add(Z_wetlands_count)\n              .divide(4))\n\n# Substituindo os locais com densidade menor que a quantidade pelos valores de quantidade             \nZ_wetlands_score = Z_wetlands_density.where(wet_test, wet_average)"
  },
  {
    "objectID": "Z_scores.html#exportando-os-valores-de-z",
    "href": "Z_scores.html#exportando-os-valores-de-z",
    "title": "Valor de Z das variáveis",
    "section": "Exportando os valores de Z",
    "text": "Exportando os valores de Z\nPor último, exportamos todas as imagens de Z como asset no Google Earth Engine.\n\n# Criando os links dos assets\n# modifique os assetIds para os dos seus projetos\n\nlandform_assetId = \"projects/ee-lucasljardim9/assets/Z_landform_variety\"\n\nelevation_assetId = \"projects/ee-lucasljardim9/assets/Z_elevation_range\"\n\nwetland_assetId = \"projects/ee-lucasljardim9/assets/Z_wetlands_score\"\n\nsoil_assetId = \"projects/ee-lucasljardim9/assets/Z_soil_diversity\"\n\n# Exportando as imagens\ngeemap.ee_export_image_to_asset(\n    Z_landform_variety, \n    description='Z_landform_variety', \n    assetId=landform_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_elevation_range, \n    description='Z_elevation_range', \n    assetId=elevation_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_wetlands_score, \n    description='Z_wetlands_score', \n    assetId=wetland_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\ngeemap.ee_export_image_to_asset(\n    Z_soil_diversity, \n    description='Z_soil_diversity', \n    assetId=soil_assetId, \n    region=regiao_box, \n    scale=escala, \n    maxPixels=1e13\n)\n\nOs dados podem ser visualizados abaixo:\n\n# Paleta de cores\n\npalette = cm.get_palette('terrain', n_class=10)\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe os assets\n\nlandform = ee.Image(\"projects/ee-lucasljardim9/assets/Z_landform_variety\")\n\nelevation_range = ee.Image(\"projects/ee-lucasljardim9/assets/Z_elevation_range\")\n\nwetland_score = ee.Image(\"projects/ee-lucasljardim9/assets/Z_wetlands_score\")\n\nsoil_diversity = ee.Image(\"projects/ee-lucasljardim9/assets/Z_soil_diversity\")\n\n\n\n# Plote o mapa\n\nMap.addLayer(landform, {'palette':palette, 'min':-1.05, 'max': 1.6}, \"landform\") \nMap.addLayer(elevation_range, {'palette':palette, 'min':-1.6, 'max': 1.5}, \"elevation range\") \nMap.addLayer(wetland_score, {'palette':palette, 'min':-0.5, 'max': 0.6}, \"wetland score\") \nMap.addLayer(soil_diversity, {'palette':palette, 'min':-2.7, 'max': 0.9}, \"soil diversity\") \n\n\nMap"
  },
  {
    "objectID": "landscape_heterogeneity.html",
    "href": "landscape_heterogeneity.html",
    "title": "Heterogeneidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA heterogeneidade da paisagem é uma métrica composta pelos valores de Z da variedade de formas de relevo, amplitude altitudinal, índice de áreas úmidas e riqueza de solos (Anderson et al. 2016). O cálculo da heterogeneidade da paisagem consiste de uma série de etapas:\n\n\nA heterogeneidade da paisagem assume os valores de variedade de formas de relevo;\n\n\nLocais onde a amplitude altitudinal é maior que variedade de formas de relevo, a heterogeneidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de de formas de relevo;\n\n\nLocais onde o índice de áreas úmidas é maior que a heterogeneidade da paisagem calculada anteriormente, os valores são substituídos pela média ponderada das variáveis, atribuindo pelo duplo para a variedade de formas de relevo;\n\n\nLocalidades onde a riqueza de solos é maior que a heterogeneidade da paisagem das etapas anteriores, os valores são substituídos pela média ponderada das variáveis naquela localidade, atribuindo peso duplo para a variedade de formas de relevo."
  },
  {
    "objectID": "landscape_heterogeneity.html#importando-pacotes-e-inicializando-geemap",
    "href": "landscape_heterogeneity.html#importando-pacotes-e-inicializando-geemap",
    "title": "Heterogeneidade da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\n\n\ngeemap.ee_initialize()\n\nA heterogeneidade da paisagem é uma métrica composta pelos valores de Z da variedade de formas de relevo, amplitude altitudinal, índice de áreas úmidas e riqueza de solos (Anderson et al. 2016). O cálculo da heterogeneidade da paisagem consiste de uma série de etapas:\n\n\nA heterogeneidade da paisagem assume os valores de variedade de formas de relevo;\n\n\nLocais onde a amplitude altitudinal é maior que variedade de formas de relevo, a heterogeneidade da paisagem é substituída pela média ponderada entre as duas variáveis, atribuindo peso dobrado para a variedade de de formas de relevo;\n\n\nLocais onde o índice de áreas úmidas é maior que a heterogeneidade da paisagem calculada anteriormente, os valores são substituídos pela média ponderada das variáveis, atribuindo pelo duplo para a variedade de formas de relevo;\n\n\nLocalidades onde a riqueza de solos é maior que a heterogeneidade da paisagem das etapas anteriores, os valores são substituídos pela média ponderada das variáveis naquela localidade, atribuindo peso duplo para a variedade de formas de relevo."
  },
  {
    "objectID": "landscape_heterogeneity.html#base-de-dados",
    "href": "landscape_heterogeneity.html#base-de-dados",
    "title": "Heterogeneidade da paisagem",
    "section": "Base de dados",
    "text": "Base de dados\nOs dados para a heterogeneidade da paisagem foram criados na etapa de cálculo dos valores de Z."
  },
  {
    "objectID": "landscape_heterogeneity.html#códigos-para-a-criação-da-heterogeneidade-da-paisagem",
    "href": "landscape_heterogeneity.html#códigos-para-a-criação-da-heterogeneidade-da-paisagem",
    "title": "Heterogeneidade da paisagem",
    "section": "Códigos para a criação da heterogeneidade da paisagem",
    "text": "Códigos para a criação da heterogeneidade da paisagem\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução da análise pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/6_landscape_diversity.ipynb.\nImportamos os dados de bioma para delimitar a região de análise e definimos a escala espacial da análise como nas etapas anteriores.\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()\n\nImportamos os mapas.\n\n# Importando e cortando as imagens para o Brasil\n# modifique os endereços para os do seu projeto\nlandform_Z = ee.Image('projects/ee-lucasljardim9/assets/Z_landform_variety')\n              \n\nelevation_range_Z = ee.Image('projects/ee-lucasljardim9/assets/Z_elevation_range')\n                    \n\nwetland_score = ee.Image('projects/ee-lucasljardim9/assets/Z_wetlands_score')\n                 \n\nsoil_diversity =  ee.Image('projects/ee-lucasljardim9/assets/Z_soil_diversity')\n\nO cálculo da heterogeneidade da paisagem inicia atribuindo à heterogeneidade da paisagem os valores de variedade de formas de relevo. Em um segundo momento, avaliamos os locais onde a amplitude altitudinal é maior que a variedade de formas de relevo e substituímos os valores.\n\nlandscape_diversity = landform_Z\n\n# Testando se o Z da amplitude altitudinal é maior que o Z da variedade de formas de relevo\ntest_1 = elevation_range_Z.gt(landscape_diversity)\n\n# Média ponderada entre variedade de formas de relevo e amplitude altitudinal\naverage_elevation = landform_Z.multiply(2).add(elevation_range_Z).divide(3)\n\n# Substituindo os valores de variedade de formas de relevo por amplitude altitudinal \n# onde o segundo valor é maior que o primeiro\nlandscape_diversity = landscape_diversity.where(test_1, average_elevation)\n\nEm seguida, adicionamos o índice de áreas úmidas, primeiro avaliando onde esse índice é maior que a heterogeneidade da paisagem calculada anteriormente. Nos locais onde os valores do índice de áreas úmidas são maiores que a heterogeneidade da paisagem, os valores são substituídos.\n\n# testando onde índice de áreas úmidas é maior que a heterogeneidade da paisagem\n\ntest_2 = wetland_score.gt(landscape_diversity)\n\n# Médias para cada teste\n\n# Locais que a amplitude altitudinal foi maior que variedade de formas de relevo\naverage_wetland_1 = landform_Z.multiply(2).add(elevation_range_Z).add(wetland_score).divide(4)\n\n# Locais onde a amplitude altitudinal não foi maior que variedade de formas de relevo\naverage_wetland_2 = landform_Z.multiply(2).add(wetland_score).divide(3)\n\n# Substitua o valor de heterogeneidade da paisagem pelo índice de áreas úmidas\n\nlandscape_diversity = landscape_diversity.where(test_1.And(test_2), average_wetland_1)\n\nlandscape_diversity = landscape_diversity.where(test_1.Not().And(test_2), average_wetland_2)\n\nA inclusão da riqueza de solos é um pouco mais complexa. Testamos onde a riqueza de solos é maior a heterogeneidade da paisagem anterior e substituímos os valores por 4 médias ponderadas diferentes, cada uma representando os passos anteriores. A primeira média é para os locais onde a riqueza de solos é maior que o índice de áreas úmidas, que por sua vez é maior que amplitude altitudinal. Na segunda média, os valores são para as regiões com maior riqueza de solos, mas onde o índice de áreas úmidas é menor que a amplitude altitudinal. A terceira média é para os locais onde a amplitude altitudinal é maior que variedade de formas de relevo, mas o índice de áreas úmidas não adiciona informação. A quarta média é para locais onde somente a riqueza de solos é maior que a variedade de formas de relevo.\n\n# teste onde riqueza de solo é maior que a heterogeneidade da paisagem\ntest_3 = soil_diversity.gt(landscape_diversity)\n\n# Calcule as médias ponderadas\naverage_soil_1 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(5))\n\naverage_soil_2 = (landform_Z.multiply(2)\n                 .add(elevation_range_Z)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_3 = (landform_Z.multiply(2)\n                 .add(wetland_score)\n                 .add(soil_diversity)\n                 .divide(4))\n\naverage_soil_4 = (landform_Z.multiply(2)\n                 .add(soil_diversity)\n                 .divide(3))\n\n# Substitua os valores de heterogeneidade da paisagem pela riqueza de solos\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2).And(test_3), average_soil_1))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.And(test_2.Not()).And(test_3), average_soil_2))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2).And(test_3), average_soil_3))\n\nlandscape_diversity = (landscape_diversity\n                      .where(test_1.Not().And(test_2.Not()).And(test_3), average_soil_4))\n\nFinalizamos exportando o mapa de heterogeneidade da paisagem como asset no Google Earth Engine.\n\n# Exporte o raster de heterogeneidade da paisagem\n# modifique assetId para o do seu projeto\nassetId = \"projects/ee-lucasljardim9/assets/landscape_heterogeneity\"\n\ngeemap.ee_export_image_to_asset(\n    landscape_diversity, \n    description='landscape_heterogeneity', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,\n    maxPixels=1e13\n)"
  },
  {
    "objectID": "resilience.html",
    "href": "resilience.html",
    "title": "Resiliência da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nA resiliência da paisagem é classificada pela heterogeneidade da paisagem e conectividade local (Anderson et al. 2016). Modificamos a metodologia original de média das métricas pela classificação pelos quantis das duas variáveis. Classificamos as métricas por quantis e atribuímos classes para as combinações de quantis de heterogeneidade da paisagem e conectividade local de cada célula. Por exemplo, células com alta heterogeneidade local (quantil superior) e alta conectividade local (quantil superior) são áreas com alta resiliência. Por outro lado, locais com baixa conectividade local e heterogeneidade da paisagem possuem baixa resiliência. Nas classes intermediárias estão as células com alta heterogeneidade da paisagem e baixa conectividadel local, e as células com alta conectividade local e baixa heterogeneidade da paisagem."
  },
  {
    "objectID": "resilience.html#importando-pacotes-e-inicializando-geemap",
    "href": "resilience.html#importando-pacotes-e-inicializando-geemap",
    "title": "Resiliência da paisagem",
    "section": "",
    "text": "import os\nimport ee\nimport geemap\nimport geemap.colormaps as cm\n\n\ngeemap.ee_initialize()\n\nA resiliência da paisagem é classificada pela heterogeneidade da paisagem e conectividade local (Anderson et al. 2016). Modificamos a metodologia original de média das métricas pela classificação pelos quantis das duas variáveis. Classificamos as métricas por quantis e atribuímos classes para as combinações de quantis de heterogeneidade da paisagem e conectividade local de cada célula. Por exemplo, células com alta heterogeneidade local (quantil superior) e alta conectividade local (quantil superior) são áreas com alta resiliência. Por outro lado, locais com baixa conectividade local e heterogeneidade da paisagem possuem baixa resiliência. Nas classes intermediárias estão as células com alta heterogeneidade da paisagem e baixa conectividadel local, e as células com alta conectividade local e baixa heterogeneidade da paisagem."
  },
  {
    "objectID": "resilience.html#base-de-dados",
    "href": "resilience.html#base-de-dados",
    "title": "Resiliência da paisagem",
    "section": "Base de dados",
    "text": "Base de dados\nOs dados utilizados para calcular a resiliência da paisagem são os mapa de heterogeneidade da paisagem e a conectividade local criados anteriormente."
  },
  {
    "objectID": "resilience.html#códigos-para-a-criação-da-resiliência-da-paisagem",
    "href": "resilience.html#códigos-para-a-criação-da-resiliência-da-paisagem",
    "title": "Resiliência da paisagem",
    "section": "Códigos para a criação da resiliência da paisagem",
    "text": "Códigos para a criação da resiliência da paisagem\nAs análises foram rodadas no Google Earth Engine (Gorelick et al. 2017), devido a demanda computacional do projeto, usando o pacote geemap (Wu 2020) em Python (Python Software Foundation 2023) como interface pela facilidade na documentação e reprodutividade das análises. O JupyterNotebook para a reprodução das análises pode ser encontrado em https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/blob/master/jupyternotebook/7_resilience.ipynb.\nPrimeiro, importamos o polígono de biomas do Brasil para extraímos as coordenadas geográficas mínimas e máximas. Extraímos também a escala do modelo digital de elevação que usamos nas análises anteriores.\n\n# Importando o polígono de bioma para definir as \n# coordenadas máximas e mínimas do Brasil\n\nregiao = ee.FeatureCollection(\"projects/ee-lucasljardim9/assets/Biome\")\n\n# ModeloDigital de Elevação para extrair a resolução\nDEM = ee.Image(\"MERIT/DEM/v1_0_3\")\n\n# função para extrair as bordas dos polígonos\ndef func_cmp(feature):\n    return feature.bounds() \n\n# Extraindo as coordenadas mínimas e máximas do Brasil\nregiao_box = regiao.map(func_cmp).geometry().dissolve(**{'maxError': 1}).bounds()\n\n# Resolução das análises\nescala = DEM.projection().nominalScale()\n\nImportamos os mapas de heterogeneidade da paisagem e conectividade local.\n\n# modifique os endereços para os do seu projeto\n\nlocal_connectedness = ee.Image(\"projects/ee-lucasljardim9/assets/local_connectedness\")\n\nlandscape_heterogeneity = ee.Image(\"projects/ee-lucasljardim9/assets/landscape_heterogeneity\")\n\nCalculamos os quantis de 25, 50, 75% da heterogeneidade da paisagem e conectividade local.\n\n# Heterogeneidade da paisagem\nquartiles_Div = landscape_heterogeneity.reduceRegion(**{\n    'reducer': ee.Reducer.percentile([25, 50, 75]), \n    'scale': escala,\n    'maxPixels':1e13,\n    'bestEffort': False\n  })\n\n# Extraímos os valores do quantis\ndiv_25 = quartiles_Div.getNumber('z_p25')\ndiv_50 = quartiles_Div.getNumber('z_p50')\ndiv_75 = quartiles_Div.getNumber('z_p75')\n\n# Conectividade local\nquartiles_Con = local_connectedness.reduceRegion(**{\n    'reducer': ee.Reducer.percentile([25, 50, 75]), \n    'scale': escala,\n    'maxPixels':1e13,\n    'bestEffort': False\n  })\n\n# Extraímos os valores do quantis\ncon_25 = quartiles_Con.getNumber('b1_p25')\ncon_50 = quartiles_Con.getNumber('b1_p50')\ncon_75 = quartiles_Con.getNumber('b1_p75')\n\nClassificamos a heterogeneidade da paisagem e conectividade local pelos quantis.\n\nclass_div = (landscape_heterogeneity\n             .where(landscape_heterogeneity.lt(div_25), 1)  \n             .where(landscape_heterogeneity.gte(div_25).And(landscape_heterogeneity.lt(div_50)), 2)\n             .where(landscape_heterogeneity.gte(div_50).And(landscape_heterogeneity.lt(div_75)), 3)\n             .where(landscape_heterogeneity.gte(div_75).And(landscape_heterogeneity), 4))\n\n\nclass_con = (local_connectedness\n             .where(local_connectedness.lt(con_25),10)\n             .where(local_connectedness.gte(con_25).And(local_connectedness.lt(con_50)), 20)\n             .where(local_connectedness.gte(con_50).And(local_connectedness.lt(con_75)),30)\n             .where(local_connectedness.gte(con_75).And(local_connectedness), 40))\n\nSomamos os mapas de heterogeneidade da paisagem e conectividade local classificados para atribuirmos as classes de resiliência.\n\nresilience = class_div.add(class_con)\n\nExportamos o mapa de resiliência como um asset no Google Earth Engine.\n\n# Exporte o raster de resiliência\n# modifique o assetId para o do seu projeto\n\nassetId = \"projects/ee-lucasljardim9/assets/resilience\"\n\ngeemap.ee_export_image_to_asset(\n    resilience, \n    description='resilience', \n    assetId=assetId, \n    region=regiao_box, \n    scale=escala,\n    maxPixels=1e13\n)\n\nO dado pode ser visualizado abaixo:\n\n# Paleta de cores\n\nsld_intervals =(\n  '&lt;RasterSymbolizer&gt;' + \\\n    '&lt;ColorMap type=\"intervals\" extended=\"False\"&gt;' + \\\n      '&lt;ColorMapEntry color=\"#d3d3d3\" quantity=\"11\" label=\"11\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#95bdd5\" quantity=\"12\" label=\"12\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#52a6d7\" quantity=\"13\" label=\"13\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#0088d9\" quantity=\"14\" label=\"14\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#d5ce9c\" quantity=\"21\" label=\"21\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#96b89e\" quantity=\"22\" label=\"22\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#53a19f\" quantity=\"23\" label=\"23\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#0085a1\" quantity=\"24\" label=\"24\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#d7c759\" quantity=\"31\" label=\"31\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#98b35a\" quantity=\"32\" label=\"32\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#539c5b\" quantity=\"33\" label=\"33\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#00815c\" quantity=\"34\" label=\"34\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#d9be00\" quantity=\"41\" label=\"41\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#9aaa00\" quantity=\"42\" label=\"42\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#549500\" quantity=\"43\" label=\"43\"/&gt;' + \\\n      '&lt;ColorMapEntry color=\"#007b00\" quantity=\"44\" label=\"44\"/&gt;' + \\\n    '&lt;/ColorMap&gt;' + \\\n  '&lt;/RasterSymbolizer&gt;')\n\n# Centralize o mapa\n\nMap = geemap.Map(center=(-11.75, -51.52), zoom=4)\n\n# Importe os assets\n\nresilience = ee.Image(\"projects/ee-lucasljardim9/assets/resilience\")\n\n\n# Plote o mapa\n\nMap.addLayer(resilience.sldStyle(sld_intervals)) \n\n\nMap"
  },
  {
    "objectID": "apresentacao.html",
    "href": "apresentacao.html",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "",
    "text": "Este documento é um tutorial para a reprodução das análises de heterogeneidade da paisagem do projeto “Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros”. A heterogeneidade da paisagem é formada pela variedade de formas de relevo, amplitude altitudinal, índice de áreas úmidas e riqueza de solos. Os passos para construção de cada variável e a combinação delas na camada final estão nos seguintes links:\nVariedade de formas de relevo (landform variety)\nAmplitude altitudinal(elevation range)\nÍndice de áreas úmidas(wetland score)\nRiqueza de solos(soil diversity)\nZ-scores\nHeterogeneidade da paisagem(landscape diversity)\nHá também o tutorial para criar a camada de resiliência da paisagem (landscape resilience), mas ela depende da camada de conectividade local (local connectivity), encontrado em outro tutorial."
  },
  {
    "objectID": "apresentacao.html#instalação-e-ambiente-para-as-análises",
    "href": "apresentacao.html#instalação-e-ambiente-para-as-análises",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Instalação e ambiente para as análises",
    "text": "Instalação e ambiente para as análises\nAs análises deste tutorial foram rodadas no Google Earth Engine (GEE) utilizando como interface o pacote geemap em Python. O tutorial está escrito no JupyterNotebook. Dessa forma, para a reprodução das análises é necessário a criação de uma conta no GEE. Em seguida, instale o Python, se não estiver instalado. Com o Python instalado, instale o JupyterNotebook. Por fim, instale o pacote geemap.\nAlguns pacotes auxiliares também são usados para produzir e exportar figuras como os e matplotlib. Escreva na linha de comando os seguintes códigos para instalar:\n\npip install os\n\npip install matplotlib\n\npip install pyxarray\n\npip install rioxarray"
  },
  {
    "objectID": "apresentacao.html#google-colab",
    "href": "apresentacao.html#google-colab",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Google colab",
    "text": "Google colab\nAs análises podem ser reproduzidas utilizando o Google Colab. Clique em Open Colab na parte superior direita da tela.\n\nEm seguida, inclua o endereço do Github (https://github.com/Resiliencia-climatica-Brasil/diversity-resilience-python/tree/master/jupyternotebook) dos arquivos de JupyterNotebook do projeto. Escolha o arquivo para abrir, por exemplo, 1_landforms.ipynb."
  },
  {
    "objectID": "apresentacao.html#bases-de-dados",
    "href": "apresentacao.html#bases-de-dados",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Bases de dados",
    "text": "Bases de dados\nOs dados utilizados nas análises já estão como assets no GEE. No entanto, se o usuário quiser adicionar outras bases de dados nas suas análises, esse tutorial ensina como fazer upload de arquivos para a sua conta no GEE."
  },
  {
    "objectID": "apresentacao.html#bases-importadas",
    "href": "apresentacao.html#bases-importadas",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Bases importadas",
    "text": "Bases importadas\n\nArquivo vetorial dos biomas do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Biome.\n\nArquivo matricial com a classificação de áreas úmidas global produzido pelo Sustainable Wetlands Adaptation and Mitigation Program ( SWAMP ), Center for International Forestry Research (CIFOR) e United States Forest Service.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Cifor_wetlands.\n\nArquivo vetorial de pedologia do Brasil produzido pelo IBGE.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/pedo_area.\n\nArquivo matricial da conectividade local produzido neste projeto utilizando o Omniscape.\n\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness."
  },
  {
    "objectID": "apresentacao.html#base-importada-do-mapbiomas",
    "href": "apresentacao.html#base-importada-do-mapbiomas",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Base importada do MapBiomas",
    "text": "Base importada do MapBiomas\nhttps://code.earthengine.google.com/?asset=projects/mapbiomas-workspace/public/collection7/mapbiomas_collection70_integration_v2."
  },
  {
    "objectID": "apresentacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "href": "apresentacao.html#bases-disponibilizadas-pelo-catálogo-do-google-earth-engine",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Bases disponibilizadas pelo catálogo do Google Earth Engine",
    "text": "Bases disponibilizadas pelo catálogo do Google Earth Engine\n\nModelo Digital de Elevação\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_DEM_v1_0_3\n\n\nAcúmulo de fluxo\nhttps://developers.google.com/earth-engine/datasets/catalog/MERIT_Hydro_v1_0_1"
  },
  {
    "objectID": "apresentacao.html#dados-produzidos-pelas-análises",
    "href": "apresentacao.html#dados-produzidos-pelas-análises",
    "title": "Mapeamento de áreas resilientes a mudanças climáticas nos biomas brasileiros",
    "section": "Dados produzidos pelas análises",
    "text": "Dados produzidos pelas análises\n\nVariedade de formas de relevo\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landform_variety\n\n\nAmplitude altitudinal\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/elevation_range_residual\n\n\nQuantidade de áreas úmidas\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_count\n\n\nDensidade de áreas úmidas local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density\n\n\nDensidade de áreas úmidas regional\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/wetlands_density_1000\n\n\nRiqueza de solos\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/soil_diversity\n\n\nValores de Z das variáveis\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_landform_variety\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_elevation_range\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_wetlands_score\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/Z_soil_diversity\n\n\nHeterogeneidade da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/landscape_heterogeneity\n\n\nConectividade local\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/local_connectedness\n\n\nResiliência da paisagem\nhttps://code.earthengine.google.com/?asset=projects/ee-lucasljardim9/assets/resilience"
  }
]